---
title: "Take-home Exercise 2: Application of Spatial and Spatio-temporal Analysis Methods to Discover the Distribution of Dengue Fever in Tainan City, Taiwan"
author: "Victoria Grace ANN"
execute: 
  warning: false
  eval: true
  echo: true
  freeze: true
format:  
  html: 
    code-summary: "Show the code"
    toc-depth: 4
date: "14 February, 2024"
date-modified: "last-modified"
editor: visual
---

# Overview

Dengue fever is a ubiquitous condition in tropical areas characterised by humid weather induced by warm temperatures and abundant rainfall. Taiwan is a subtropical region and its weather conditions cause it to be a favourable breeding ground for female Aedes aegypti and Aedes albopictus mosquitoes.

In 2015, Taiwan In 2015, Taiwan had recorded the most severe dengue fever outbreak with more than 43,000 dengue cases and 228 deaths. Since then, the annual reported dengue fever cases were maintained at the level of not more than 200 cases. However, in 2023, Taiwan recorded 26703 dengue fever cases (Kam, 2024).

For this project, the study area focuses on Southwest Tainan, and epidemiology weeks 31 through 50 in 2023.

# Getting Started

## Loading necessary packages

For this project we need the following packages:

-   **tidyverse** for importing, wrangling and visualising data

-   **lubridate** to work with time-related data more easily

-   **dplyr** for attribute data handling

-   **sf** to handle spatial data

-   **tmap** to plot choropleth maps

-   **sfdep** to compute spatial contiguity weights

-   **gifski** to save gif files

-   **Kendall** to perform Mann-Kendall test

```{r}
pacman::p_load(tidyverse, lubridate, dplyr, sf, tmap, sfdep, gifski, Kendall)
```

## Importing data

### Geospatial

Read the Tainan boundary layer.

```{r}
tn_sf <- st_read("data/geospatial/TAINAN_VILLAGE.shp")
```

```{r}
tn_sf <- st_transform(tn_sf, crs = 3824)
plot(st_geometry(tn_sf))
```

::: {callout-note}
The coordinates are employing the TWD97 geodetic system, which translates to EPSG ID 3824.
:::

```{r}
#| echo: false
summary(tn_sf)
```

### Aspatial

```{r}
dengue <- read_csv("data/aspatial/Dengue_Daily.csv")
```

# Confining Data to Study Area and Time Period

## Tainan Geospatial Data

This project will focus towns with IDs D01, D02, D04, D06, D07, D08, D36, D39.

Hence, confine the geospatial data to the study area,

```{r}
tainan_aoi <- tn_sf %>%
  filter(TOWNID %in% c("D01", "D02", "D04", "D06", "D07", "D08", "D32", "D39"))

summary(tainan_aoi)
```

View how the different towns are located geographically by using a choropleth map via **tmap**.

```{r}
study_townids <- c("D01", "D02", "D04", "D06", "D07", "D08", "D32", "D39")

tn_sf_filtered <- tn_sf %>%
  mutate(highlight = ifelse(TOWNID %in% study_townids, "Study", "Not Study"))
```

```{r}
main_map <- tm_shape(tn_sf_filtered) +
  tm_polygons("highlight", palette = c("grey", "red")) +
  tm_borders(lwd = 0.2, alpha = 1) +
  tm_layout(main.title = "Overview of Tainan", main.title.size = 1) +
  tm_scale_bar()

secondary_map <- tm_shape(tainan_aoi) +
  tm_polygons(col = "TOWNID") +
  tm_layout(legend.show = TRUE, main.title = "Overview of Dengue Study Area", main.title.size = 1) +
  tm_scale_bar()

tm_layout(legend.show = FALSE)

tmap_arrange(main_map, secondary_map, ncol = 2)
```

## Dengue Data

First, let's find out more about our dengue data.

Check the *class* type of the dengue data set.

```{r}
class(dengue)
```

-   Currently, the dengue data set is a tibble data frame.

Browse through the first few rows.

```{r}
head(dengue)
```

The data is in Traditional Chinese? No problem! The following table is a rough guide on all the attributes:

| Attribute             | Translation                                       |
|------------------------|-----------------------------------------------|
| **發病日**            | **Onset date**                                    |
| 個案研判日            | Assessed date                                     |
| 通報日                | Notification date                                 |
| 性別                  | Gender                                            |
| 年齡層                | Age group                                         |
| 居住縣市              | Residential city                                  |
| 居住鄉鎮              | Residential township                              |
| 居住村里              | Residential village                               |
| 最小統計區            | Smallest statistical area                         |
| **最小統計區中心點X** | **X-coordinate** of the smallest statistical area |
| **最小統計區中心點Y** | **Y-coordinate** of the smallest statistical area |
| 一級統計區            | Level 1 statistical area                          |
| 二級統計區            | Level 2 statistical area                          |
| 感染縣市              | Infected city                                     |
| 感染鄉鎮              | Infected township                                 |
| 感染村里              | Infected village                                  |
| 是否境外移入          | Imported case?                                    |
| 感染國家              | Imported country origin                           |
| **確定病例數**        | **Confirmed case count**                          |
| 居住村里代碼          | Residential village code                          |
| 感染村里代碼          | Infected village code                             |
| 血清型                | Serotype                                          |
| 內政部居住縣市代碼    | Residential city (Internal Affairs)               |
| 內政部居住鄉鎮代碼    | Residential township (Internal Affairs)           |
| 內政部感染縣市代碼    | Infected city code (Internal Affairs)             |
| 內政部感染鄉鎮代碼    | Infected township code (Internal Affairs)         |

Since the data includes all of Taiwan's confirmed dengue cases from 1998 to January 2024, the data needs to be further confined to year 2023, epidemiology weeks 31 to 50.

Extract all the 2023 dengue cases.

```{r}
dengue_2023 <- subset(dengue, substr(發病日, 1, 4) == "2023")
```

Create a column to store the epidemiology week number for the respective dates. We can use a function called *epiweek()* from the [**lubridate**](https://lubridate.tidyverse.org/reference/week.html) package to carry this task out.

```{r}
dengue_2023$epi_week <- epiweek(dengue_2023$發病日)
```

Filter for epidemiology weeks 31 to 50.

```{r}
dengue_study <- dengue_2023 %>%
  filter(epi_week >= 31 & epi_week <= 50)
```

According to [Health Protection Surveillance Centre](https://www.hpsc.ie/notifiablediseases/resources/epidemiologicalweeks/), epidemiology weeks 31 to 50 are from 2023-07-30 to 2023-12-16.

Then verify that the earliest and latest date in **tainan_dengue_2023** are 2023-07-30 and 2023-12-16 respectively.

```{r}
earliest_date <- min(dengue_study$發病日)
latest_date <- max(dengue_study$發病日)

earliest_date == "2023-07-30"
latest_date == "2023-12-16"
```

::: callout-note
#### Important

Since it is my first time using the *epiweek()* function, I felt it was important to refer to an official medical source explicitly stating the start and end dates of our interested study period. Hence, I performed a quick test to check if there was any mistake in the usage of this unfamiliar function.
:::

Earlier, the dengue data type identified was tibble data frame. To perform an intersection between the study area boundary and our dengue study data, `dengue_study` needs to be converted to sf data frame format since `tainan_aoi` is in that format.

```{r}
class(tainan_aoi)
```

Ensure coordinates are numeric. If not, convert them to numeric.

```{r}
#| echo: false
class(dengue_study$最小統計區中心點X)
class(dengue_study$最小統計區中心點Y)

dengue_study$最小統計區中心點X <- as.numeric(dengue_study$最小統計區中心點X)
dengue_study$最小統計區中心點Y <- as.numeric(dengue_study$最小統計區中心點Y)

class(dengue_study$最小統計區中心點X)
class(dengue_study$最小統計區中心點Y)
```

```{r}
dengue_study_clean  <- dengue_study %>%
  filter(is.numeric(最小統計區中心點X) & is.numeric(最小統計區中心點Y))

nrow(dengue_study) == nrow(dengue_study_clean)
```

::: callout-tip
#### Learning Point

When performing the *as.numeric()* on `dengue_study`, there were no changes in rows. On second thought, the function will not include rows that do not contain numeric characters!
:::

Remove missing coordinates.

```{r}
dengue_study <- dengue_study %>% 
  filter(!is.na(最小統計區中心點X), !is.na(最小統計區中心點Y))
```

Now, `dengue_study` can be converted to sf data frame.

```{r}
dengue.sf <- st_as_sf(dengue_study, 
                      coords = c("最小統計區中心點X","最小統計區中心點Y"),
                      crs=3824)
```

Confine `dengue.sf` into dengue cases recorded in just Tainan City, i.e. 台南市.

```{r}
aoi_dengue.sf <- subset(dengue.sf, 居住縣市 == "台南市")
```

Consolidate `dengue.sf` and keep the columns that are needed only.

```{r}
colnames(aoi_dengue.sf)

aoi_dengue.sf <- aoi_dengue.sf %>%
  select(發病日, 性別, 年齡層, 感染國家, 確定病例數, epi_week, geometry)
```

::: callout-note
I have decided to extract the onset date, gender, age group, country of infection, count, epidemiology week and geometry. Technically, the gender, age group, and country of infection need not be included.
:::

Finally, an intersection between `tainan_aoi` and `aoi_dengue.sf` to confine the dengue cases to the study area can be performed using \`*st_intersection()*

```{r}
#| eval: false
st_crs(tainan_aoi)
st_crs(aoi_dengue.sf)
aoi_dengue <- st_intersection(tainan_aoi, aoi_dengue.sf)
```

```{r}
#| eval: false
write_rds(aoi_dengue, "data/geospatial/aoi_dengue.rds")
```

```{r}
aoi_dengue <- readRDS("data/geospatial/aoi_dengue.rds")
class(aoi_dengue)
nrow(aoi_dengue)
```

## Aggregating Dengue Data

Get a proper consolidated data set where the dengue cases are sorted by their unique village codes.

```{r}
v_dengue <- aoi_dengue %>%
  group_by(VILLCODE) %>%
  summarise(count = n()) %>%
  st_drop_geometry()

v_dengue.sf <- left_join(tainan_aoi,v_dengue) %>%
  select(1, tail(names(.), 2)) %>%
  complete(VILLCODE, fill = list(count = 0)) %>%
  st_as_sf()
```

Get a proper consolidated data set where the dengue cases are sorted by their unique village codes and epidemiology weeks.

```{r}
vw_dengue <- aoi_dengue %>%
  group_by(VILLCODE, epi_week) %>%
  summarise(count = n()) %>%
  st_drop_geometry()

vw_dengue <- left_join(tainan_aoi,vw_dengue) %>%
  select(1, tail(names(.), 3)) %>%
  complete(VILLCODE, epi_week = 31:50, fill = list(count = 0)) %>%
  st_drop_geometry() %>%
  select(1:3) %>%
  drop_na()
```

```{r}
#| eval: false
vw_dengue.sf <- left_join(tainan_aoi, vw_dengue) %>%
  select(1, tail(names(.), 3)) %>%
  complete(VILLCODE, epi_week = 31:50, fill = list(count = 0)) %>%
  st_as_sf()

vw_dengue.sf <- vw_dengue.sf[!is.na(vw_dengue.sf$epi_week), ]

write_rds(vw_dengue.sf, "data/geospatial/vw_dengue.sf")
```

::: callout-note
### Note

In the data, there are some villages that do not have cases or have no recorded cases for some weeks. Using *complete()*, we can iterate through our study period weeks and *fill* them with the `count` value of 0
:::

```{r}
vw_dengue.sf <- read_rds("data/geospatial/vw_dengue.sf")
```

# Exploratory Data Analysis

I am interested how the dengue cases are distributed across space and time.

In general, here is the distribution of dengue cases across ...

## Across Space

::: panel-tabset
### Barplot

```{r}
ggplot(aoi_dengue, aes(x = TOWNID)) +
  geom_bar(fill = "steelblue", color = "black", bins = 20) +
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5)
  labs(x = "TOWNID", y = "Number of Dengue Cases", Title = "Histogram of Dengue cases by District Town") 
```

### Choropleth Map

```{r}
tmap_mode("plot")
tm_shape(v_dengue.sf) +
  tm_fill("count",
          style = "jenks",
          title = "count") +
  tm_layout(main.title = "Distribution of Dengue Cases per Village",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```
:::

### Across Time

```{r}
ggplot(aoi_dengue, aes(x = epi_week)) +
  geom_bar(fill = "blue", color = "black") +
 labs(x = "Epidemiology Week", y = "Count", title = "Barplot of Dengue Cases across EWeeks")
```

From **tmap**, *tm_facets()* can be used to split our maps according to epidemiology week.

```{r}
dengue_anim <- tm_shape(vw_dengue.sf) +
  tm_fill("count", palette = "Blues") +
  tm_borders(lwd = 0.1) +
  tm_facets(along = "epi_week", free.coords = FALSE)

dengue_anim
```

::: callout-note
#### Legend Scale

Notice that the legend scale and bins are equal across all the rendered maps
:::

```{r}
#| eval: false
tmap_animation(dengue_anim, filename = "dengue.gif", delay = 100, width = 1280, height = 720, scale = 2)
```

```{r}
knitr::include_graphics("dengue.gif")
```

Corresponding to the tallest bar from the earlier histogram for the dengue cases per week, there were the most dengue cases reported in epidemiology week 39. In the same week, there was a village in the east of our study area that demonstrated the highest case count of at least 60, the highest count for a village during the study period.

# Spatial Autocorrelation

Spatial autocorrelation analysis gathers a set of statistics that describes how a variable like dengue likelihood is autocorrelated through space.

It is typical to first identify if the whole data set is geographically clustered or dispersed. This step is known as global spatial autocorrelation and the statistic used to measure global autocorrelation is global Moran's I.

By extension, local spatial autocorrelation enables the evaluation of individual features like individual villages by comparing to their neighbours and checks for any clustering or dispersion.

Global and local spatial autocorrelation results can be compared and any anomaly can be identified.

# Global Spatial Autocorrelation

## Deriving contiguity weights

Each geometry is defined by a unique village. In order to test for any spatial autocorrelation, spatial weights must be assigned to each of the villages. In a more theoretical context, these villages are neighbours.

```{r}
dengue.wm_q <- v_dengue.sf %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb, style="W"),
         .before = 1)
```

```{r}
glimpse(dengue.wm_q)
```

## Global Moran's I Test

```{r}
global_moran_test(dengue.wm_q$count,
                  dengue.wm_q$nb,
                  dengue.wm_q$wt)
```

The Moran I statistic standard deviate is 12.869, indicating that there is positive spatial autocorrelation.

The low p-value reveals that the spatial correlation is statistically significant.

## Global Moran I's Permutation Test

To perform a simulation of Moran's I test via \`*global_moran_perm()*, use *set.seed()* to ensure that the results generated are consistent.

```{r}
set.seed(1234)

global_moran_perm(dengue.wm_q$count,
                  dengue.wm_q$nb,
                  dengue.wm_q$wt,
                  nsim = 99)
```

There is sufficient statistical evidence to reject the null hypothesis that the spatial distribution of dengue cases in our areas of interest in Tainan city resembles random spatial distribution. Evidently, the Moran's I test statistic is greater than 0 and we can infer that the spatial distribution resembles signs of clustering.

# Local Spatial Autocorrelation

Local indicators of Spatial Association (LISA) statistics measure the extent to which points that are close to a given point have similar based on a contiguity measure among these points within a specified radius and thus are useful for identifying local spatial autocorrelation (Anselin, 1995).

## Computing Local Moran's I

Local Moran's I is the most popular spatial statistical method to detect for spatial clusters and outliers.

```{r}
lisa <- dengue.wm_q %>%
  mutate(local_moran = local_moran(count, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)
```

### Visualising local Moran's I

```{r}
tmap_mode("plot")
map1 <- tm_shape(lisa) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Dengue Cases",
            main.title.size = 0.8)

map1
```

```{r}
tmap_mode("plot")
tm_shape(lisa) +
  tm_fill("p_ii_sim") + 
  tm_borders(alpha = 0.5) +
   tm_layout(main.title = "p-value of local Moran's I",
            main.title.size = 0.8)
```

::: callout-warning
#### Warning

The appropriate classification for p-values should be 0.001, 0.01, 0.05 and not significant.
:::

```{r}
tmap_mode("plot")

map2 <- tm_shape(lisa) +
  tm_fill("p_ii_sim", breaks = c(0, 0.001, 0.01, 0.05, 1),
          labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
   tm_layout(main.title = "p-value of local Moran's I",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

-   Looking at the map on the right, villages with a lighter orange have values closer to 0 which signify that they have significant clustering and their neighbouring areas exhibit similar values. These villages seem to mostly disperse at the fringes of our study area.

### Visualising LISA map

Now, just filter for regions which had significant p-values and plot the map.

```{r}
lisa_sig <- lisa  %>%
  filter(p_ii < 0.05)

lisa_map <- 
tm_shape(lisa) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4) +
  tm_scale_bar() +
  tm_layout(legend.show = TRUE, main.title = "Overview of Outliers and Clusters", main.title.size = 1)

tmap_mode("plot")
tmap_arrange(lisa_map, secondary_map, ncol = 2)
```

::: callout-note
#### What do the LISA classifications mean?

-   High-High Clusters: Villages with high number of dengue cases likewise surrounded by neighbouring villages with high number of dengue cases.

-   Low-Low Clusters: Villages of a low number of dengue cases are similarly surrounded by neigbouring villages with low number of dengue cases

-   High-Low Outliers: Villages with high number of dengue cases are instead surrounded by neighbouring villages with low number of dengue cases

-   Low-High Outliers: Villages with low number of dengue cases are instead surrounded by neighbouring villages with high number of dengue cases
:::

The northwest and central-southeast villages of our Tainan area of interest have been identified as low-low clusters, thus their neighbours have had low-values or cases in general across the weeks.

Interestingly, high-high clusters are found along the most part of a radial perimeter 3km away from the centre of the study area. These high-high clusters lie in Districts:

-   D01: East District

-   D02: South District

-   D06: An'nan District

-   D39: Yong'kang District

The municipality for these high-high clusters should impose more safety mechanisms to alleviate dengue transmissions.

There were no high-low outliers identified and hence it is possible that there is no specific village that may be a local hotspot that may directly contribute to the dengue transmissions to its neighbours.

Nearby the high-high clusters, there were five low-high outlier villages which could be worth investigating since these villages are not as affected as its badly infected neighbouring villages.

# Hot Spot and Cold Spot Area Analysis

Gi\* statistics help to add definition to maps by estimating the density distribution of events at the local level, which further allows for the assessment of spatial association in a study area or of a particular observation.

Additionally, it helps to identify statistically significant hotspots and coldspots.

## Computation of local Gi\*

```{r}
wm_idw <- v_dengue.sf %>%
  mutate(nb = st_contiguity(geometry),
         wts = st_inverse_distance(nb, geometry,
         scale = 1,
         alpha = 1),
.before = 1)
```

::: callout-note
### Interpreting code

-   The data used here (`v_dengue.sf`) contains the consolidated data categorised by space, not space and time since we are only focusing on **spatial autocorrelation**

-   `st_contiguity(geometry)`: Derives and identifies neighbours by reading sf polygon objects. Its sibling argument is [*st_knn()*](https://search.r-project.org/CRAN/refmans/sfdep/html/st_knn.html)

-   `st_inverse_distance()`: calculates an inverse distance weight from the prior neighbour list and sf geometry column. Other weights can be calculated from *st_kernel_weights()*, *sth_nb_dists()* and *st_weights()*
:::

```{r}
HCSA <- wm_idw %>% 
  mutate(local_Gi = local_gstar_perm(
    count, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_Gi)
HCSA
```

## Visualising Gi\*

```{r}
tmap_mode("plot")
tm_shape(HCSA) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8))
```

Beginning from the epicentre of the study area, the values of Gi\* seem to decrease radially in general. Closer to the centre, the more positive Gi\* values indicate a greater density of dengue cases whilst the more negative Gi\* values indicate more randomness in the distribution of dengue cases in the villages.

::: callout-warning
#### Disadvantage of using Gi\* statistic

Clusters composed of few observations may inflate Gi\* although other methods that allow the selection of only the most robust clusters is available.
:::

### Visualising p-value of HCSA

```{r}
tmap_mode("plot")
tm_shape(HCSA) +
  tm_fill("p_sim") + 
  tm_borders(alpha = 0.5)
```

### Visualising General Local HCSA

Implement the correct p-value classification in the p-value map visualisation.

```{r}
tmap_mode("plot")
map3 <- tm_shape(HCSA) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Dengue Case Count",
            main.title.size = 0.8)

map4 <- tm_shape(HCSA) +
  tm_fill("p_value",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map3, map4, ncol = 2)
```

Villages that are insignificant indicate that their dengue cases are more likely due to geographical proximity.

## Visualising General Hot & Cold spot areas

```{r}
HCSA_sig <- HCSA  %>%
  filter(p_sim < 0.05)

tmap_mode("plot")

HCSA_sig_map <- tm_shape(HCSA) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.4) +
  tm_layout(main.title = "Gi*",
            main.title.size = 1) +
  tm_scale_bar()

tmap_arrange(lisa_map, HCSA_sig_map, ncol = 2)
```

Several cold spots are observed along the northern region of the study area as well as some southern villages.

# Emerging Hot Spot Analysis

Hot spot analysis utilises Getis-Ord or Gi\* statistics where they are, by extension, local indicators of spatial association. More information can be found from Josiah Parry's succinct explanation on the fundamentals of hot spot analysis [here](https://www.youtube.com/watch?v=sjLyJW95fHM). (He is also the author of the sfdep pacakge!)

## Creating Time Series Cube

Use *spacetime()* of **sfdep** package to create a spatio-temporal cube.

```{r}
tn_st <- spacetime(vw_dengue, tainan_aoi, 
                   .loc_col = "VILLCODE",
                   .time_col = "epi_week",
                   active = "data")

is_spacetime_cube(tn_st)
```

## Deriving Spatial Weights

Compute spatial weights by deriving inverse distance weights to compute the Gi\* statistics

```{r}
tn_nb <- tn_st %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         wt = st_inverse_distance(nb, geometry,
                                  scale = 1,
                                  alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

::: callout-tip
### Interpreting the above code block

-   `activate()` activates the geometry context of the layer, and thus the layer should contain a polygon geometry attribute
-   `mutate()` creates new columns *nb* and *wt*
-   Activate the data context again and copy to the *nb* and *wt* columns to every time-slice using `set_nbs()` and `set_wts()`
:::

## Computation of Gi\*

Use *local_gstar_perm()* of **sfdep** package and group by `epi_week` to manually calculate the local Gi\* statistic for each village `VILLCODE`. After which, use unnest() to unnest the gi_star column of the new dataframe.

```{r}
gistars <- tn_nb %>%
  group_by(epi_week) %>%
  mutate(gi_star = local_gstar_perm(count, nb, wt)) %>%
  unnest(gi_star)
```

With the statistic, we can merge our geometry to plot and see the statistical trends of the local GI\* statistic

```{r}
gistar_map <- left_join(tainan_aoi, gistars,
                          by = c("VILLCODE" = "VILLCODE"))
```

Create the tmap plot for the `gi_star` statistic over time.

::: {callout-note}
Use p_sim to use the simulated values and use fixed style and breaks to plot the values that were P \< 0.05, which are areas that are significant.
:::

```{r}
gistar_map <- gistar_map %>% mutate(`P-Value` = case_when(p_sim < 0.05 ~ '< 0.05',  p_sim >= 0.05 ~ 'Not-Significant'))

gistar_tmap <-
  tm_shape(gistar_map) + 
    tm_fill("P-Value") +
    tm_borders(lwd = 0.1) +
    tm_facets(along = "epi_week", free.coords = FALSE) + 
  tm_scale_bar()
```

```{r}
#| eval: false
tmap_animation(gistar_tmap, filename = "gistar.gif", delay = 100, width = 1280, height = 720, scale = 2)
```

```{r}
knitr::include_graphics("gistar.gif")
```

Villages in light blue mean that the p-value is less than 0.05, indicating that they are significantly associated with higher OR lower dengue cases compared to their neighbouring villages.

Generally, there are different significant areas across the study period.

The north western region of our study area in Tainan appears to be significant from epidemiology weeks 36 to 46.

## Mann-Kendall Test and Gi\*

### Exploratory Data Analysis

First, locations can be evaluated through the Mann-Kendall test. This non-parametric test assesses if a set of data values is increasing or decreasing over time and also if the direction of the trend is statistically significant.

The *MannKendall()* function is to identify whether the dengue cases are growing or decreasing with time.

```{r}
ehsa <- gistars %>%
  group_by(VILLCODE) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  unnest_wider(mk)
```

```{r}
gistars_merged <- merge(gistars, tainan_aoi[c("VILLCODE", "VILLENG", "TOWNID", "TOWNNAME")], by = "VILLCODE", all.x = TRUE)
```

To have a look at all the Gi\* statistics across all the villages, the following function can be used.

```{r}
#| eval: false
unique_villeng <- unique(gistars_merged$VILLENG)

create_plot <- function(villeng) {
  cbg <- gistars_merged %>%
    ungroup() %>%
    filter(VILLENG == villeng) %>%
    select(VILLENG, epi_week, gi_star)
  
  ggplot(data = cbg, aes(x = epi_week, y = gi_star)) +
    geom_line() +
    theme_light() +
    ggtitle(paste("VILLENG:", villeng))
}
```

```{r}
#| eval: false
plots_list <- map(unique_villeng, create_plot)
plots_list
write_rds(plots_list, "gistars_plots")
```

```{r}
plots_list <- read_rds("gistars_plots")
```

::: callout-warning
Since the above two code chunks requires a lot of computation time, I have saved `plots_list` as a rds file.
:::

There are some Gi\* graphs of some villages that caught my attention. So let's plot them out.

```{r}
interested_vills <- c("Fuqian Vil.", "Nanhua Vil.", "Shenggong Vil.")

vills_filtered <- tainan_aoi %>%
  mutate(highlight = ifelse(VILLENG %in% interested_vills, "Intersting", "NA"))
```

```{r}
tm_shape(vills_filtered) +
  tm_polygons("highlight", palette = c("red","grey")) +
  tm_borders(lwd = 0.2, alpha = 1) +
  tm_layout(main.title = "Overview of Initial Interested Villages", main.title.size = 1) +
  tm_scale_bar()
```

::: callout-note
### What is a Census Block Group (CBG)?

It is a unit of census geography that is a combination of census blocks typically used in the [United States](https://support.esri.com/en-us/gis-dictionary/block-group). However, another such of a unit of measurement is not available globally, hence I employ census block group for easier reference.
:::

#### Initial CBGs

::: panel-tabset
#### Shenggong Village

```{r}
cbg_sg <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Shenggong Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

#### Nanhua Village

```{r}
cbg_nh <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Nanhua Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

#### Fuqian Village

```{r}
cbg_fq <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Fuqian Vil.") |>
  select(VILLENG, epi_week, gi_star)
```
:::

### Gi\* Temporal Trends

Hypothesis:

H0: There is no monotonic time-series trend.

H1: A positive, negative or non-null trend exists.

```{r}
ggplot() +
  geom_line(data = cbg_sg, mapping = aes(x = epi_week, y = gi_star, color = "Shenggong Village")) +
  geom_line(data = cbg_nh, mapping = aes(x = epi_week, y = gi_star, color = "Nanhua Village")) + 
  geom_line(data = cbg_fq, mapping = aes(x = epi_week, y = gi_star, color = "Fuqian Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for 3 villages",
       color = "Village")
```

Let's check these villages and the significance of the local dengue cases over time.

::: panel-tabset
#### Shenggong Village

```{r}
cbg_sg %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```

#### Nanhua Village

```{r}
cbg_nh %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```

#### Fuqian Village

```{r}
cbg_fq %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>% 
  tidyr::unnest_wider(mk)
```
:::

::: callout-note
#### Note

The p-value is represented by attribute *sl*.
:::

All the villages that caught my attention with my naked eye have insignificant time-series trends for their dengue cases. Thus there are no monotonic time-series trends detected.

Let's check out where are the locations with significant time-series trends!

```{r}
filter_vill <- function(data) {
  result <- data %>%
    group_by(VILLCODE,VILLENG) %>%
    summarise(mk = list(unclass(Kendall::MannKendall(gi_star)))) %>%
    tidyr::unnest_wider(mk) %>%
    filter(sl < 0.05)
  
  return(result)
}

sig_vills <- filter_vill(gistars_merged)
```

```{r}
#| echo: false
sig_vills %>% arrange(tau)
```

From the results above, we can observe that about 5.43% of all the villages (14 of 258) in the study area only possess significant trends denoted by a p-value (sl) of less than 0.05.

The greatest downward and upward trends in dengue cases were exhibited in Huaping Village and Chenggong Village respectively according to their tau values.

## Significant Census Block Groups

::: panel-tabset
#### Huaping Village

```{r}
cbg_hp <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Huaping Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_hp, mapping = aes(x = epi_week, y = gi_star, color = "Huaping Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Huaping Village",
       color = "Village")
```

#### Jiading Village

```{r}
cbg_jd <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Jiading Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_jd, mapping = aes(x = epi_week, y = gi_star, color = "Jiading Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Jiading Village",
       color = "Village")
```

#### Haidong Village

```{r}
cbg_hd <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Haidong Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_hd, mapping = aes(x = epi_week, y = gi_star, color = "Haidong Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Haidong Village",
       color = "Village")
```

#### Zhuxi Village

```{r}
cbg_zx <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Zhuxi Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_zx, mapping = aes(x = epi_week, y = gi_star, color = "Zhuxi Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Zhuxi Village",
       color = "Village")
```

#### Dongqiao Village

```{r}
cbg_dq <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Dongqiao Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_dq, mapping = aes(x = epi_week, y = gi_star, color = "Dongqiao Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Dongqiao Village",
       color = "Village")
```

#### Lixing Village

```{r}
cbg_lx <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Lixing Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_lx, mapping = aes(x = epi_week, y = gi_star, color = "Lixing Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Lixing Village",
       color = "Village")
```

#### Guangzhou Village

```{r}
cbg_gz <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Guangzhou Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_gz, mapping = aes(x = epi_week, y = gi_star, color = "Guangzhou Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Guangzhou Village",
       color = "Village")
```

#### Xiaoximen Village

```{r}
cbg_xm <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Xiaoximen Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_xm, mapping = aes(x = epi_week, y = gi_star, color = "Xiaoximen Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Xiaoximen Village",
       color = "Village")
```

#### Zhongxi Village

```{r}
cbg_zx2 <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Zhongxi Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_zx2, mapping = aes(x = epi_week, y = gi_star, color = "Zhongxi Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Zhongxi Village",
       color = "Village")
```

#### Dongwan Village

```{r}
cbg_dw <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Dongwan Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_dw, mapping = aes(x = epi_week, y = gi_star, color = "Dongwan Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Dongwan Village",
       color = "Village")
```

#### Jincheng Village

```{r}
cbg_jc <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Jincheng Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_jc, mapping = aes(x = epi_week, y = gi_star, color = "Jincheng Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Jincheng Village",
       color = "Village")
```

#### Zhongzhou Village

```{r}
cbg_zz <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Zhongzhou Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_zz, mapping = aes(x = epi_week, y = gi_star, color = "Zhongzhou Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Zhongzhou Village",
       color = "Village")
```

#### Diandong Village

```{r}
cbg_dd <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Diandong Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_dd, mapping = aes(x = epi_week, y = gi_star, color = "Diandong Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Diandong Village",
       color = "Village")
```

#### Da'en Village

```{r}
cbg_de <- gistars_merged %>%
  ungroup() %>%
  filter(VILLENG == "Da'en Vil.") |>
  select(VILLENG, epi_week, gi_star)
```

```{r}
ggplot() +
  geom_line(data = cbg_de, mapping = aes(x = epi_week, y = gi_star, color = "Da'en Village")) +
  labs(x = "Epi Week", y = "Gi* Value", 
       title = "Gi* over time for Da'en Village",
       color = "Village")
```
:::

### Summary of Significant CBGs

Generally, six of the significant villages had consistent negative Gi\* values over the weeks. These villages are Zhuxi, Lixi, Zhongxi, Dongwan, Jincheng and Zhongzhou. Only Dongqiao village had a consistent positive Gi\* value across the weeks.

Guangzhou, Xiaoximen, Huaping and Diandong villages were initially spatial outliers that became spatial clusters that occurred less likely by chance as time progressed. Xiaoximen increased the most from epidemiology week 31 to 50 in Gi\* value. This similar increasing trend was also observed by Huaping. Haidong village had a very sharp increase in Gi\* from -2.7 to 1 starting from week 44. Thus a spatial cluster was formed in this village in the last seven weeks of the study period. Furthermore, Dongqiao village consistently had positive Gi\*, thus it was constantly a spatial cluster of dengue cases.

# Overall

```{r}
ehsa <- gistars %>%
  group_by(VILLCODE) %>%
  summarise(mk = list(
    unclass(
      Kendall::MannKendall(gi_star)))) %>%
  tidyr::unnest_wider(mk)

nrow(ehsa[ehsa$sl < 0.05,])/nrow(ehsa[ehsa$sl >= 0.05,])
```

A majority 59.3% of the total villages have significant trends regardless of their directions.

## All Villages

From the **sfdep** package, *emerging_hotspot_analysis()* can be used. The purpose is to check if temporal trends are associated with dengue rates or if dengue rates are solely situated in a spatial context.

```{r}
ehsa <- emerging_hotspot_analysis(
  x = tn_st,
  .var = "count",
  k = 1,
  nsim = 99
)
```

-   The k argument is used to specify the number of time lags which is set to 1 by default.

To view the distribution of EHSA classes, we can use *ggplot()*.

## Distribution of EHSA Classes

```{r}
ggplot(data = ehsa,
       aes(x = classification)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

::: callout-tip
### What do the EHSA classifications mean?

1.  Consecutive: Consistently low or high in dengue cases over an extended period
2.  Oscillating: Consistent dengue fluctuations at either lower or higher levels
3.  Sporadic: Inconsistent cases over time
4.  No Pattern Detected: No particular pattern observed
:::

The highest number of over 100 villages are classified as oscillating hotspots. This means that these villages is a wavering cluster as it has been a significant cold spot before it became a hot spot towards the end of the observed time period.

The next highest bar making up over 50 villages are classified as oscillating coldspots. Conversely, these villages are wavering clusters due to being a hotspot before becoming a cold spot towards the end of the study time period.

### Visualising EHSA

Currently, `ehsa` does not have any spatial characteristic. Hence it needs to join with `tainan_aoi` to obtain the geospatial characteristics.

```{r}
tn_ehsa <- tainan_aoi %>%
  left_join(ehsa,
            by = join_by(VILLCODE == location))
```

Filter for significant locations.

```{r}
ehsa_sig <- tn_ehsa %>%
  filter(p_value < 0.05)

ehsa_sig_map <- tm_shape(tn_ehsa) +
  tm_polygons(id="VILLENG") +
  tm_borders(alpha = 0.5) +
tm_shape(ehsa_sig) +
  tm_fill("classification",id="VILLENG") + 
  tm_borders(alpha = 0.4) +
  tm_scale_bar()

tmap_mode("view")

ehsa_sig_map
```

In general, most of the study area is characterised by hotspots rather than coldspots. Specifically, there are a significant number of oscillating hotspots in the study area.

In total, seven villages had no detected patterns.

```{r}
filter(tn_ehsa, classification == "no pattern detected")$VILLENG
```

```{r}
filter(tn_ehsa, classification == "consecutive coldspot")$VILLENG
```

```{r}
filter(tn_ehsa, classification == "consecutive hotspot")$VILLENG
```

```{r}
filter(tn_ehsa, classification == "oscilating coldspot")$VILLENG
```

```{r}
filter(tn_ehsa, classification == "oscilating hotspot")$VILLENG
```

These oscillating hotspots still have considerable dengue cases throughout the study period. Additionally, these villages may have remained as oscillating hotspots due to the [warmer autumn and winter seasons](https://www.taipeitimes.com/News/taiwan/archives/2023/10/25/2003808201).

```{r}
filter(tn_ehsa, classification == "sporadic coldspot")$VILLENG
```

According to Tainan City's Climate [data](https://en.climate-data.org/asia/republic-of-china-taiwan/tainan-city/tainan-city-983291/t/december-12/) in 2023, our study period which falls between August and December has had an average temperature of 24.5C which is within the optimal temperature for dengue fever transmission ([Tran et al., 2020](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7068348/)).

# References

Anselin, L. (1995). Local Indicators of Spatial Association—LISA. Geographical Analysis 27(2): 93–115.

Columbia Mailman School of Public Health (n.d.). Hot Spot Spatial Analysis. https://www.publichealth.columbia.edu/research/population-health-methods/hot-spot-spatial-analysis

Kam, T. S. (2022). R for Geospatial Data Science and Analytics. https://r4gdsa.netlify.app

Lee, I. (2023) Dengue fever cases dropping, but risk still there: CDC.

Parry, J., & Locke, D. H. (2022). Emerging Hot Spot Analysis. sfdep. https://sfdep.josiahparry.com/articles/understanding-emerging-hotspots.html

Tran, B., Tseng, W., Chen, C., & Liao S. (2020) Estimating the Threshold Effects of Climate on Dengue: A Case Study of Taiwan.
