---
title: "Take-home Exercise 3 (Revised): Exploratory Spatial Data Analysis for Potential Push & Pull Factors of Locations in Singapore using Public Bus Data"
author: "Victoria Grace ANN"
execute: 
  warning: false
  eval: true
  echo: true
  freeze: true
format:  
  html: 
    code-summary: "Show the code"
    toc-depth: 4
date: "11 March, 2024"
date-modified: "last-modified"
editor: visual
---


# 1.0   Overview

In this exercise, my focus would be on prototyping exploratory spatial data analysis, particularly density of spatial assets within hexagonal traffic analysis zones. In conventional geography, a traffic analysis zone is the unit most commonly used in transportation planning models and the size of it varies. Hexagonal traffic analysis zones has gained traction as the hexagons of the study area have a uniform size which are easily comparable with each other when determining transport attractiveness. It is also recommended that hexagon radius should be 125m for areas in high urbanisation and 250m in areas with less urbanisation (Chmielewski et al., 2020).

The data preparation for this purpose also supports the preparation for calibrating spatial interaction models. For the prototyping, only exploratory spatial data analysis will be done.

# 2.0   Package Installation

I will load up the below R packages for the following purposes:

-   tmap: to visualise spatial data by creating thematic maps that could be interactive or static.

-   sf: to manipulate spatial data.

-   sp: to manipulate spatial data (older than sp).

-   reshape2: to reshape and transform data frames; converting data between "wide" and "long" formats using functions like melt().

-   ggplot2: to visualise data with plot types including bar plots.

-   tidyverse: to clean and transform data and contains sub-packagess including tidyr, dplyr and readr.

-   stplanr: to provide functions suitable for working with spatial transport data like networks, orgins-destinations matrices and travel time matrices; builds on the capabilities of sf and sp packages.

-   knitr: to combine code into a single documents that can be easily converted to various output formats like html, pdf, or Word.

-   kableExtra: to further style any Kables.

-   spdep: to create spatial wieght matrix objects from contiguities

-   spflow: to estimate spatial econometric interaction models

```{r}
pacman::p_load(tmap, sf, sp, reshape2, ggplot2, ggpubr, tidyverse, stplanr, knitr, kableExtra, spdep)

devtools::install_github("LukeCe/spflow")
library(spflow)
```


# 3.0   Data sources


-   URA's Masterplan Subzone 2019 Layer in shapefile format

-   Bus Stop Locations extracted from LTA

-   A tabulated bus passenger flow for Nov 2023, Dec 2023 and Jan 2024 from LTA dynamic data mall

-   Population Data for 2023 from SingStat

-   Schools from MOE

-   Financial Services

-   Hospitals, polyclinics and CHAS clinics derived from Google Maps


# 4.0   Data preparation 

# 4.1   Data preparation for bus-induced hexagons


::: panel-tabset

## Bus Stops Layer

Read the aspatial bus stop layer and set its CRS to 3414.

```{r}
BusStop <- read.csv("data/aspatial/bus_coords_subzone_v2.csv") %>% st_as_sf(coords=c("Longitude", "Latitude"), crs=4326) %>%
  st_transform(crs=3414)
```


## Subzone Layer

Read the subzone layer

```{r}
#| eval: false
mpsz <- st_read("data/geospatial/master-plan-2019-subzone-boundary-no-sea-kml.kml")
```

Convert `mpsz` to 2D geometry.

```{r}
#| eval: false
mpsz <- st_zm(mpsz, drop = TRUE) # Convert 3D geometries to 2D
```

Extract the `SUBZONE_N` and `PLN_AREA_N` from the `Dscrptn` field

For SUBZONE_N,

```{r}
#| eval: false
mpsz <- mpsz %>%
  rowwise() %>%
  mutate(SUBZONE_N = str_extract(Description, "<th>SUBZONE_N</th> <td>(.*?)</td>")) %>%
  ungroup()

mpsz$SUBZONE_N <- str_remove_all(mpsz$SUBZONE_N, "<.*?>|SUBZONE_N")
```

For PLN_AREA_N,

```{r}
#| eval: false
mpsz <- mpsz %>%
  rowwise() %>%
  mutate(PLN_AREA_N = str_extract(Description, "<th>PLN_AREA_N</th> <td>(.*?)</td>")) %>%
  ungroup()

mpsz$PLN_AREA_N <- str_remove_all(mpsz$PLN_AREA_N, "<.*?>|PLN_AREA_N")
```

Remove the `Description` column.

```{r}
#| eval: false
mpsz$Description <- NULL
```

Remove unwanted outer islands.

```{r}
#| eval: false
mpsz3414 <- st_transform(mpsz, 3414)

outer_islands <- c("SEMAKAU", "SUDONG", "NORTH-EASTERN ISLANDS", "SOUTHERN GROUP")
mpsz3414 <- mpsz3414 %>%
  filter(!str_trim(SUBZONE_N) %in% str_trim(outer_islands))
```

Create the shapefile.

```{r}
#| eval: false
st_write(mpsz3414, "data/geospatial/mpsz_sf.shp", append=FALSE)
```


Read the updated shapefile.

```{r}
mpsz_sf <- st_read("data/geospatial/mpsz_sf.shp")
```


## Spatial Grids Layer

The goal to create incoming and outgoing bus traffic flow visualisations from trip origins to trip destinations only requires hexagons containing bus stops.

Let's look at how bus stops are distributed in Singapore.

```{r}
tmap_options(check.and.fix = TRUE)

tm_shape(mpsz_sf) +
  tm_polygons(title = "Singapore Boundary") +
  tm_layout(main.title = "Bus stops in Singapore",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_shape(BusStop) +
  tm_dots(col = "red", size = 0.005, title = "Bus Stops") +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```


There are a few bus stops that are located in Malaysia after the Tuas Checkpoint. Since they are geographically beyond Singapore's boundary, these bus stops need to be removed.


```{r}
BusStop <- BusStop %>%  
  st_intersection(mpsz_sf) %>%
  select(BusStopCode,)
```


Some regions like the Central Water Catchment area and the west-end of Singapore do not have any bus stops. To make the hexagons containing bus stops,

```{r}
hex_sg <- BusStop %>% st_make_grid(
  cellsize = 750,
  what = "polygons",
  square = FALSE) %>%
  st_sf() %>%
  mutate(index = as.factor(row_number()))

mpsz_border <- mpsz_sf %>% st_union()
hex_sg2 <- st_intersection(hex_sg, mpsz_border)
```

```{r}
hex_grids <- hex_sg %>%
  filter(lengths(st_intersects(geometry, BusStop)) > 0)
```


::: {.callout-tip collapse="true"}
### Code interpretation
-   st_make_grid: creates grids 

-   cellsize: hexagon size determined by twice the length of the apothem

-   st_sf: set the hexagons as a sf object

-   filter: filtering for hexagons that contain bus stops 

-   mutate: creating index IDs for the filtered hexagons based on the row number
:::


```{r}
tm_shape(mpsz_sf) +
  tm_polygons(title = "Singapore Boundary") +
  tm_shape(hex_grids) +
  tm_polygons(col = "white") +
  tm_layout(main.title = "Hexagons with SG Bus Stops",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_shape(BusStop) +
  tm_dots(col = "red", size = 0.005, title = "Bus Stops") +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha = 0.2)
```
:::


# 4.2 Constructing bus commuter flow data

::: {.callout-note collapse="true"}
## Combining OD data

```{r}
#| eval: false
od_bus_nov <- read_csv("data/OD Bus/merged_bus_nov_v2.csv")
od_bus_dec <- read_csv("data/OD Bus/merged_bus_dec_v2.csv")
od_bus_jan <- read_csv("data/OD Bus/merged_bus_jan_v2.csv")
```

```{r}
#| eval: false
OD <- rbind(od_bus_nov, od_bus_dec)
OD <- rbind(OD, od_bus_jan)

nrow(od_bus_nov) + nrow(od_bus_dec) + nrow(od_bus_jan) == nrow(OD) # evaluates to TRUE
```

```{r}
#| eval: false
str(OD)
```

`ORIGIN_PT_CODE` and `DESTINATION_PT_CODE` are listed as character variables. These variables should be transformed to factors so that R treats them as grouping variables.

```{r}
#| eval: false
cols_to_convert <- c("ORIGIN_PT_CODE", "DESTINATION_PT_CODE")

OD[cols_to_convert] <- lapply(OD[cols_to_convert], as.factor)

glimpse(OD)
```

ORIGIN_PT_CODE`and`DESTINATION_PT_CODE\` are now factors.

```{r}
#| eval: false
write_rds(OD, "data/rds/odbus_combined.rds")
```

```{r}
#| eval: false
odbus_combined <- read_rds("data/rds/odbus_combined.rds")
```

:::

::: {.callout-note collapse="true"}
## Creating Commute Flow Data

```{r}
#| eval: false
od <- odbus_combined %>%
  group_by(ORIGIN_PT_CODE, ORIGIN_SUBZONE, DESTINATION_PT_CODE, DESTINATION_SUBZONE, DAY_TYPE ,TIME_PER_HOUR) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS)) %>%
  ungroup()

write_rds(od, "data/rds/od.rds")
```

```{r}
#| eval: false
od <- read_rds("data/rds/od.rds")
```
:::

:::{.callout-note collapse="true"}
## Geospatial Wrangling
Now we need to convert the od data from aspatial to geospatial data.

First, we populate the hexagon grid indexes of `hex_grid_bounded2` sf data frame into `BusStop` sf data frame using *st_intersection()*.

```{r}
#| eval: false
BusStop_hex <- st_intersection(BusStop, hex_sg) %>%
  select(BusStopCode, index) %>%
  st_drop_geometry()

cols_to_convert <- c("BusStopCode")
BusStop_hex[cols_to_convert] <- lapply(BusStop_hex[cols_to_convert], as.factor)

glimpse(BusStop_hex)
```

Append the hexagon grid index from `BusStop_hex` data frame to the segregated od data frames for both `ORIGIN_PT_CODE` and `DESTINATION_PT_CODE`.

```{r}
#| eval: false
od_data <- left_join(od, BusStop_hex,
            by = c("ORIGIN_PT_CODE" = "BusStopCode")) %>%
  rename("ORIGIN_hex" = "index")

od_data <- left_join(od_data, BusStop_hex,
            by = c("DESTINATION_PT_CODE" = "BusStopCode")) %>%
  rename("DESTIN_hex" = "index") %>%
  drop_na() %>%
  group_by(ORIGIN_hex, ORIGIN_SUBZONE, DESTIN_hex, DESTINATION_SUBZONE, DAY_TYPE, TIME_PER_HOUR) %>%
  summarise(TOTAL_TRIPS = sum(TRIPS))

cols_to_convert <- c("ORIGIN_hex", "DESTIN_hex")

od_data[cols_to_convert] <- lapply(od_data[cols_to_convert], as.factor)
```


```{r}
#| eval: false
write_rds(od_data, "data/rds/od_data.rds") 
```

```{r}
od_data <- read_rds("data/rds/od_data.rds")
```
:::


::: {.callout-note collapse="true"}
## Remove intra-zonal flows

It is not meaningful to include trips that started and ended from the same point, so we will only include point pairs where the origin and destination of a trip are different.

```{r}
#| eval: false
od_plot <- od_data[od_data$ORIGIN_hex!=od_data$DESTIN_hex,]
```

:::

::: {.callout-note collapse="true"}
## Create desire lines

Use *od2line()* of **stplanr** package to create the desire lines.

```{r}
#| eval: false
od_plot <- od_plot[, c(1, 3, 2, 4:ncol(od_plot))]

flowLine <- od2line(flow = od_plot, 
                    zones = hex_grids,
                    zone_code = "index")
```

::: callout-tip
### Learning Point
The flow data in the `od2line` function must have the origin and destination indexes in its first two columns.
:::

Write and read the flowline layer.

```{r}
#| eval: false
write_rds(flowLine, "data/rds/flowLine.rds")
```


```{r}
flowLine <- read_rds("data/rds/flowLine.rds")
```

:::



# 5.0   Spatial Push & Pull Factors

Push factors are reasons for pushing people or passengers away from their location. Pull factors are reasons for attracting passenger to a location. These are the factor densities I am looking into:

-   **Population density** of an area has an impact on movement patterns as higher population density areas can act as a propulsive force. The HDB data will be used as a proxy for the population density, where a greater number of units will indicate a higher population density.

-   **Employment opportunities density** of an area can also contribute a location's push or pull. An area with more businesses will attract more workers to the area and thus the registered business data will be used as a proxy.

-   **School Density** can determine the volume of passengers commuting to an area as an area with more schools would attract more human traffic whilst an area with fewer or no schools will not attract students especially during school hours.

-   **Financial Services Density** can contribute to the overall attractiveness of a destination of a destination for employment by offering convenience.

-   **Public Healthcare Density** can reflect the utility of polyclinics and public hospitals through the traffic network.


# 5.1   Data preparation for POIs

::: panel-tabset

## Population

::: {.callout-note}

### Importing Aspatial HDB data

Use *read_csv()* from the **readr** package to import the prepared HDB csv data.

```{r}
hdb <- read_csv("data/aspatial/hdb.csv")
```


For the purpose of computing a proxy for population density, the residential units will be extracted using *filter()* from the **dplyr** package.

```{r}
hdb_residential <- hdb %>%
  filter(residential == "Y")

head(hdb_residential, 10)
```


There are also some outliers like hotels that are classified as a residential unit. We can remove rows containing 'hotel' using *grepl()*.

```{r}
hotels <- hdb_residential %>%
  filter(grepl("HOTEL", building, ignore.case = TRUE))

kable(hotels)
```


The HDB Blk 1 Beach Road shares a similar address as Raffles Hotel's 1 Beach Road, but they have different postal codes.

To verify other similar addresses, filter for addresses containing "BEACH RD".

```{r}
beach_rd <- hdb_residential %>%
  filter(grepl("BEACH RD", street, ignore.case = TRUE))

kable(beach_rd)
```


2, 5 and 15 Beach Road do not have the correct postal codes following the 1900XX convention. Additionally, these addresses do not have the correct coordinates too.

With reference to URA's official asset map of Singapore, OneMap, the data will be manually modified using *mutate()* and *ifelse()*.

```{r}
hdb_residential2 <- hdb_residential %>%
  mutate(postal = ifelse(blk_no == 1 & street == "BEACH RD", 190001, postal)) %>%
  mutate(lat = ifelse(blk_no == 1 & street == "BEACH RD", 1.3036714, lat)) %>%
  mutate(lng = ifelse(blk_no == 1 & street == "BEACH RD", 103.8644787, lng)) %>%
  mutate(postal = ifelse(blk_no == 2 & street == "BEACH RD", 190002, postal)) %>%
  mutate(lat = ifelse(blk_no == 2 & street == "BEACH RD", 1.3040331, lat)) %>%
  mutate(lng = ifelse(blk_no == 2 & street == "BEACH RD", 103.8649285, lng)) %>%
  mutate(postal = ifelse(blk_no == 3 & street == "BEACH RD", 190003, postal)) %>%
  mutate(lat = ifelse(blk_no == 3 & street == "BEACH RD", 1.3041872, lat)) %>%
  mutate(lng = ifelse(blk_no == 3 & street == "BEACH RD", 103.8651934, lng)) %>%
  mutate(postal = ifelse(blk_no == 5 & street == "BEACH RD", 190005, postal)) %>%
  mutate(lat = ifelse(blk_no == 5 & street == "BEACH RD", 1.3043463, lat)) %>%
  mutate(lng = ifelse(blk_no == 5 & street == "BEACH RD", 103.8648158, lng)) %>%
  mutate(postal = ifelse(blk_no == 15 & street == "BEACH RD", 190015, postal)) %>%
  mutate(lat = ifelse(blk_no == 15 & street == "BEACH RD", 1.3034254, lat)) %>%
  mutate(lng = ifelse(blk_no == 15 & street == "BEACH RD", 103.8631535, lng))
```

Check for any duplicates.

```{r}
duplicate <- hdb_residential2 %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()

DT::datatable(duplicate)
```


:::

::: {.callout-note}

### Converting Aspatial data to Geospatial data

Longitude and latitude values are in decimal degrees and thus the data is in wgs84 geographic coordinate system.

To convert `hdb_residential2` into sf, we use *st_as_sf()* and set the `crs` argument to 4326 first. The transformation to Singapore's coordinate reference system 3414 will be done with *st_transform()*.

We only need the postal code, total dwelling units and geometry attributes so we will use the *select()* function to extract these columns.

```{r}
hdb_residential_sf <- st_as_sf(hdb_residential2, 
                   coords = c("lng", "lat"),
                   crs=4326) %>%
  st_transform(crs = 3414) %>%
  select(postal, total_dwelling_units, geometry)

str(hdb_residential_sf)
```
:::

::: {.callout-note}
### Performing in-polygon count

```{r}
housing_count <- st_join(hex_sg, hdb_residential_sf, 
                     join = st_intersects, left = TRUE) %>%
  st_drop_geometry() %>%
  group_by(index) %>%
  summarise(housing_count = sum(total_dwelling_units)) %>%
  ungroup() %>%
  mutate(housing_count = ifelse(is.na(housing_count), 0, housing_count))
```

```{r}
hex_sg2 <- left_join(hex_sg, housing_count,
                               by = c("index" = "index"))

summary(hex_sg2$housing_count)
```
:::


## Business

::: {.callout-note}

### Import Geospatial data: Business

```{r}
biz <- st_read("data/geospatial/Business.shp") %>% st_transform(crs=3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$biz_count <- lengths(st_intersects(hex_sg2, biz))

summary(hex_sg2$biz_count)
```

:::

## School

::: {.callout-note}

### Import aspatial data: School

```{r}
schools <- read_csv("data/aspatial/schoolsclean.csv")

schools <- schools %>%
  separate(latlong, into = c("latitude", "longitude"), sep = ",", convert = TRUE)

schools_sf <- st_as_sf(schools, coords = c("longitude","latitude"), crs = 4326) %>% 
  st_transform(crs=3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$school_count <- lengths(st_intersects(hex_sg2, schools_sf))

summary(hex_sg2$school_count)
```

:::


## Financial Services

::: {.callout-note}

### Import Geospatial data: Financial Services

```{r}
FinServ <- st_read(dsn = "data/geospatial", layer = "FinServ") %>%
  st_transform(crs = 3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$fin_count <- lengths(st_intersects(hex_sg2, FinServ))

summary(hex_sg2$fin_count)
```

:::


## Public Healthcare

::: {.callout-note}

### Import aspatial data: Healthcare

```{r}
public_hc <- read_csv("data/aspatial/HospitalsPolyclinics v_2024.csv")

public_hc.sf <- st_as_sf(public_hc[1:42,], wkt = "geometry", crs = 4326) %>% 
  st_transform(crs=3414)

public_hc2.sf <- st_as_sf(public_hc[43:1235,], wkt = "geometry", crs = 3414) # CHAS clinics encoded in EPSG 3414 

public_hc.sf <- rbind(public_hc.sf, public_hc2.sf)

#write_rds(public_hc.sf, "data/geospatial/public_hc.sf")
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$hc_count <- lengths(st_intersects(hex_sg2, public_hc.sf))

summary(hex_sg2$hc_count)
```

:::


## Leisure & Recreation

::: {.callout-note}

### Import Geospatial data: Leisure & Recreation

```{r}
leisure_recre <- st_read("data/geospatial/Liesure&Recreation.shp") %>% st_transform(crs=3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$leisure_recre_count <- lengths(st_intersects(hex_sg2, leisure_recre))

summary(hex_sg2$leisure_recre_count)
```

:::


## Food & Beverages

::: {.callout-note}

### Import Geospatial data: F&B

```{r}
food_bev <- st_read("data/geospatial/F&B.shp") %>% st_transform(crs=3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$food_bev_count <- lengths(st_intersects(hex_sg2, food_bev))

summary(hex_sg2$food_bev_count)
```

:::


## Retail

::: {.callout-note}

### Import Geospatial data: Leisure & Recreation

```{r}
retail <- st_read("data/geospatial/Retails.shp") %>% st_transform(crs=3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$retail_count <- lengths(st_intersects(hex_sg2, retail))

summary(hex_sg2$retail_count)
```

:::


## Entertainment

::: {.callout-note}

### Import Geospatial data: Entertainment

```{r}
entertn <- st_read("data/geospatial/entertn.shp") %>% st_transform(crs=3414)
```

:::

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$entertn_count <- lengths(st_intersects(hex_sg2, entertn))

summary(hex_sg2$entertn_count)
```

:::

## Bus Stop

::: {.callout-note}

### Perform point-in-polygon count

```{r}
hex_sg2$bus_count <- lengths(st_intersects(hex_sg2, BusStop))

summary(hex_sg2$bus_count)
```

-   There are up to 20 bus stops in a study hexagon.

:::

:::


# 5.2 Visualisation of POI densities

::: panel-tabset

## Bus Stop

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "bus_count",
          palette = "Blues",
          style = "cont", 
          title = "Bus Stop Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Population

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "housing_count",
          palette = "Blues",
          style = "cont", 
          title = "Housing Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Business

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "biz_count",
          palette = "Blues",
          style = "cont", 
          title = "Business Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## School

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "school_count",
          palette = "Blues",
          style = "cont", 
          title = "School Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Financial Services

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "fin_count",
          palette = "Blues",
          style = "cont", 
          title = "Financial Services Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Public Healthcare

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "hc_count",
          palette = "Blues",
          style = "cont", 
          title = "Public Healthcare Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Leisure & Recreation

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "leisure_recre_count",
          palette = "Blues",
          style = "cont", 
          title = "Leisure & Recreation Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Food & Beverages

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "food_bev_count",
          palette = "Blues",
          style = "cont", 
          title = "F&B Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Retail

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "entertn_count",
          palette = "Blues",
          style = "cont", 
          title = "Entertainment Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```


## Entertainment

```{r}
tm_shape(hex_sg2) +
  tm_fill(col = "entertn_count",
          palette = "Blues",
          style = "cont", 
          title = "Entertainment Density") + 
  tm_borders(col = "grey")  +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4)
```

:::


# 6.0   Distance Matrix Computation

# 6.1   Prepare Origin & Destination Variables

::: {.callout-note collapse="true"}
## Origin (Propulsive)

```{r}
propulsive <- hex_sg2 %>%
  st_drop_geometry() %>%
  select(index, biz_count, school_count, fin_count, hc_count, bus_count, housing_count, leisure_recre_count, retail_count, entertn_count, food_bev_count)
  

origin <- names(propulsive) %>%
  modify_at(-1, ~ paste0("o_", .))  # Add prefix to all except index

# Assign modified names back to the data frame
names(propulsive) <- origin
```
:::

::: {.callout-note collapse="true"}
## Destination

```{r}
attractiveness <- hex_sg2 %>%
  st_drop_geometry() %>%
  select(index, biz_count, school_count, fin_count, hc_count, bus_count, housing_count, leisure_recre_count, retail_count, entertn_count, food_bev_count)
  

destin <- names(propulsive) %>%
  modify_at(-1, ~ paste0("d_", .))  # Add prefix to all except index

# Assign modified names back to the data frame
names(attractiveness) <- destin
```
:::

# 6.2    Construction

A distance matrix shows the distance between pairs of locations. A location's distance from itself is shown in the main diagonal of a distance matrix table.

In view of time, we will use sp rather than sf.

```{r}
hex_grid_sp <- as(hex_grids, "Spatial")
```

```{r}
dist <- spDists(hex_grid_sp, longlat = FALSE)

# resultant matrix
head(dist, n=c(10, 10))
```
::: {.callout-note}
The result is a matrix object class and the column and row headers are not labeled with the hexagon grid index representing the TAZ.
:::

## Label column and row headers

Create a list sorted according to the distance matrix by Traffic Analytical Zones.

```{r}
hex_names <- hex_grids$index
```

Attach the hexagon grid index to the rows and columns for distance matrix matching.

```{r}
colnames(dist) <- paste0(hex_names)
rownames(dist) <- paste0(hex_names)
```

## Pivot distance value by hexagon grid index

The distance matrix is pivoted into a long table by using the *melt()* function of **reshape2**.

```{r}
distPair <- reshape2::melt(dist) %>%
  rename(dist = value)

head(distPair, 10)
```

-   The intra-zonal distances are 0.

## Update intra-zonal distances

Check for the lowest non-zero distance value.

```{r}
distPair %>%
  filter(dist > 0) %>%
  summary()
```

Since the lowest distance is 750m, any distance less than 750m can represent the intra-zonal distance. For consistency, 375m is appended to intra-zonal distances.

:::{.callout-warning, collapse="true}
### Warning: Do not leave distances at zero value

In Poisson regression, log is applied to the distances and distances need to be set as positive values.
:::

```{r}
distPair$dist <- ifelse(distPair$dist == 0,
                        375, distPair$dist)

summary(distPair)
```

Rename the origin and destination fields and convert into factor data type.

```{r}
distPair <- distPair %>%
  rename(orig = Var1,
         dest = Var2) %>%
  mutate(across(c(orig, dest), as.factor))
```

#   6.3 Separating intra-flow from passenger volume

A new column `FlowNoIntra` is created to differentiate intra-zone trips from inter-zone trips based on the comparison of origin and destination zones.

```{r}
od_data$FlowNoIntra <- ifelse(
  od_data$ORIGIN_hex == od_data$DESTIN_hex, 0, od_data$TOTAL_TRIPS)
od_data$offset <- ifelse(
  od_data$ORIGIN_hex == od_data$DESTIN_hex, 0.000001, 1)
```

```{r}
od_data <- od_data%>%
  filter(FlowNoIntra > 0)
```

## Combining passenger volume data with distance value

Convert the data value type into factor for the origin and destination hex indexes.

```{r}
od_data$ORIGIN_hex <- as.factor(od_data$ORIGIN_hex)
od_data$DESTIN_hex <- as.factor(od_data$DESTIN_hex)
```

Then perform a left join to join the OD data and distPair. Store it under `flow_data`.

```{r}
flow_data <- od_data %>%
  left_join (distPair,
             by = c("ORIGIN_hex" = "orig",
                    "DESTIN_hex" = "dest"))
```

## Preparing origin attributes

```{r}
flow_data <- flow_data %>%
  left_join (propulsive,
             by = c("ORIGIN_hex" = "index"))
```

## Preparing destination attributes

```{r}
flow_data <- flow_data %>%
  left_join (attractiveness,
             by = c("DESTIN_hex" = "index"))
```

## Check for variables with zero values

For log transformation, log 0 is undefined so it is critical to ensure there are no zero values in the explanatory variables.

```{r}
#| eval: false
#| echo: false
summary(flow_data)
```

All except the bus stop count variables contain zero values and need to be replaced with a negligible value like 0.99.

```{r}
#| eval: false
flow_data <- flow_data %>%
  mutate_at(vars(ends_with("_count")), ~ ifelse(. == 0, 0.99, .))

write_rds(flow_data, "data/rds/flow_data.rds")
```

```{r}
flow_data <- read_rds("data/rds/flow_data.rds")
```

## Apply log transformation

Poisson regression is based on log, so log() has to be applied to all our explanatory variables before calibrating the various spatial interaction models.

```{r}
#| eval: false
flow_data_log <- flow_data %>%
  mutate_at(vars(ends_with("_count")), log) %>%
  mutate(dist = log(dist))

summary(flow_data_log)
```


#   7.0 Spatial Econometric Interaction Modelling

##    7.1 Spatial Interaction Model
SIM is a mathematical model predicting the movement of people between origins (like homes) and destinations by examining the distance between them.

In a healthcare context, a SIM can account the likely demand for health services and the quality of service provision at health centres. Conventionally, SIM's cousin term is gravity model.


:::{.callout-note collapse="true"}
## Variable Construction

```{r}
# Generate propulsive variables names
origin_var <- propulsive %>%
  select(-(index)) %>%
  names()

# Generate attractiveness variables names
destin_var <- attractiveness %>%
  select(-(index)) %>%
  names()
```
:::


:::{.callout-note collapse="true"}
## Origin Constrained Model

```{r}
#| eval: false
# Generate the formula dynamically
formula_string <- paste("TOTAL_TRIPS ~ ORIGIN_hex +", 
                        paste(destin_var, collapse = " + "), "+ dist - 1")

# Convert the string to a formula
formula <- as.formula(formula_string)

orcSIM <- glm(formula,
              family = poisson(link = "log"),
              data = flow_data_log,
              na.action = na.exclude)

write_rds(orcSIM, "data/rds/decSIM.rds")
```

```{r}
orcSIM <- read_rds("data/rds/orcSIM.rds")
summary(orcSIM)
```
:::

:::{.callout-note collapse="true"}
## Destination Constrained Model

```{r}
#| eval: false
# Generate the formula dynamically
formula_string <- paste("TOTAL_TRIPS ~ DESTIN_hex +", 
                        paste(destin_var, collapse = " + "), "+ dist - 1")

# Convert the string to a formula
formula <- as.formula(formula_string)

decSIM <- glm(formula,
              family = poisson(link = "log"),
              data = flow_data_log,
              na.action = na.exclude)

write_rds(decSIM, "data/rds/decSIM.rds")
```

```{r}
#| eval: false
decSIM <- read_rds("data/rds/decSIM.rds")
summary(decSIM)
```
:::


:::{.callout-note collapse="true"}
## Doubly Constrained Model

```{r}
#| eval: false
dbcSIM <- glm(formula = TOTAL_TRIPS ~ 
                ORIGIN_hex + 
                DESTIN_hex + 
                dist,
              family = poisson(link = "log"),
              data = flow_data_log,
              na.action = na.exclude)

write_rds(dbcSIM, "data/rds/dbcSIM.rds")
```

```{r}
#| eval: false
dbcSIM <- read_rds("data/rds/decSIM.rds")
summary(dbcSIM)
```
:::




##    7.2 Spatial Econometric Interaction Modelling

Spatial Econometric Interaction Models extend the traditional SIM by considering econometric matters. It addresses the limitation of SIM which assumes there is independence across observations. SEIM addresses the spatial dependencies across observations and acknowledge that nearby locations might influence each other's behaviour or out comes. Additionally, SEIM handles spatial autocorrelation more effectively and addresses multicollinearity.


Three data sets are needed to calibrate SEIM using **spflow** package:

-   Spatial Weights

-   Distance Matrix

-   Explanatory Variables

::: {.callout-note collapse="true"}
## Preparing Spatial Weights

The connectivity between traffic analytical zones can be described using contiguity, fixed distance and adaptive distance matrices.

```{r}
coords <- hex_sg2 %>% 
  filter(bus_count > 0) %>%
  select(geometry) %>%
  st_centroid()

k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = FALSE))

summary(k1dists)
```

:::{callout-tip}
### Interpreting Summary Report
The largest first nearest neighbour distance is 3269m and it will be used as the upper threshold such that all k neighbours have at least one neighbour.
:::

:::


::: {.callout-note collapse="true"}

## Computing Spatial Weights

```{r}
centroids <- suppressWarnings({
    st_point_on_surface(st_geometry(hex_sg2))})

hexgrid_nb <- list(
  "by_contiguity" = poly2nb(hex_sg2),
  "by_distance" = dnearneigh(centroids, 
                             d1 = 0, d2 = 3269),
  "by_knn" = knn2nb(knearneigh(centroids, 6))
)

hexgrid_nb
```
:::

::: {.callout-note collapse="true"}

## Prepare Flow Data

```{r}
flow_data1 <- flow_data %>%
  group_by(ORIGIN_hex, DESTIN_hex) %>%
  summarise(TOTAL_TRIPS = sum(TOTAL_TRIPS), dist = first(dist))
```

:::


::: {.callout-note collapse="true"}

## Prepare Explanatory Variables

```{r}
explanatory <- hex_sg2 %>%
  st_drop_geometry()
```

:::

::: {.callout-note collapse="true"}

## Create spflow_network-class objects

```{r}
hex_net <- spflow_network(
  id_net = "sg",  # assign an id name, can give it any input
  node_neighborhood = nb2mat(hexgrid_nb$by_distance),
  node_data = explanatory,
  node_key_column = "index"
)

hex_net
```


```{r}
hex_net_pairs <- spflow_network_pair(
  id_orig_net = "sg",
  id_dest_net = "sg",
  pair_data = flow_data1,
  orig_key_column = "ORIGIN_hex",
  dest_key_column = "DESTIN_hex"
)

hex_net_pairs
```


```{r}
hex_multi_net <- spflow_network_multi(hex_net, hex_net_pairs)

hex_multi_net
```

:::

## Correlation Analysis


```{r}
# Generate explanatory variables names
var_name <- explanatory %>%
  select(-(index)) %>%
  names()

# Generate the formula dynamically
cor_formula <- log(1 + TOTAL_TRIPS) ~ 
  bus_count + 
  housing_count + 
  biz_count + 
  school_count + 
  fin_count + 
  hc_count + 
  leisure_recre_count +
  food_bev_count + 
  retail_count + 
  entertn_count + 
  P_(log(dist + 1))

cor_mat <- pair_cor(
  hex_multi_net, 
  spflow_formula = cor_formula, 
  add_lags_x = FALSE)

colnames(cor_mat) <- paste0(
  substr(
    colnames(cor_mat),1,3),"...")

cor_image(cor_mat)
```

Given that there are no variable pairs that are very highly correlated with one another, all variables will be used to calibrate the SEIM.


## 7.2.1    SEIM Calibration

```{r}
base_model <- spflow(
  spflow_formula = log(1 + TOTAL_TRIPS) ~ 
    O_(bus_count + 
  housing_count + 
  biz_count + 
  school_count + 
  fin_count + 
  hc_count + 
  leisure_recre_count +
  food_bev_count + 
  retail_count + 
  entertn_count) +
    D_(bus_count + 
  housing_count + 
  biz_count + 
  school_count + 
  fin_count + 
  hc_count + 
  leisure_recre_count +
  food_bev_count + 
  retail_count + 
  entertn_count) +
    P_(log(dist + 1)),
  spflow_networks = hex_multi_net)

base_model
```

### Residual diagnostics

```{r}
old_par <- par(mfrow = c(1, 3), 
               mar = c(2,2,2,2))

spflow_moran_plots(base_model)
```


### Visualise Fitted Values

```{r}
model.df <- as_tibble(base_model@spflow_indicators) %>%
  mutate(FITTED_Y = round(exp(FITTED),0))

inter_zonal_flow <- flow_data %>%
  left_join(model.df) %>%
  mutate(diff = (FITTED_Y-TOTAL_TRIPS))
```

```{r}
ggplot(data = inter_zonal_flow,
                aes(x = FITTED,
                    y = ACTUAL)) +
  geom_point() +
  geom_smooth(method = lm) +
  coord_cartesian(xlim=c(0,14),
                  ylim=c(0,14)) + 
  labs(title = "Observed vs. Fitted Values for SEIM",
       x = "Fitted Values", y = "Observed Values")
```


#   8.0 Prototype

In light of our class project, I aim to test the feasibility of plotting out the various commuting flow maps.

Specifically, the maps can focus on the various areas of interest and plot the flow lines originating and ending in AOIs of ranged densities.

The analytical unit could be planning area, subzone or even hexagonal.

Before diving into these analytical units, we can have a look at the general inflow and outflows from origins and destinations.

# Level 1: General Perspective

The `TOTAL_TRIPS` is set to 3000 at minimum due to computational time taken to run the below code chunks.

```{r}
flowLine <- filter(flowLine, TOTAL_TRIPS>=3000)
```

Split outgoing and incoming flows along with the origin and destination hexagon layers.

```{r}
#| eval: false
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_sg2$index)
org_hex <- filter(hex_sg2, index %in% flowLine_org$ORIGIN_hex)

flowLine_dest <- filter(flowLine, DESTIN_hex %in% hex_sg2$index)
dest_hex <- filter(hex_sg2, index %in% flowLine_dest$DESTIN_hex)
```

## General Outflows from Origins (Propulsive)

Here, I assume that the user is interested in bus traffic flows and where buses typically leave.

```{r}
#| eval: false
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_sg2, index %in% flowLine_org$ORIGIN_hex)

org_hex_3000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 3000], ]

tm_shape(hex_sg2) +
  tm_borders(col = "grey") +
tm_shape(org_hex_3000) + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%  
  filter(TOTAL_TRIPS >= 3000) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Origin: Desire Lines Traffic Analysis Zones \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
  
```


The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(2).png)

## Inflows to Destinations (Attractive)

This scenario assumes that the user is interested in the popular bus destinations, i.e. `TOTAL_TRIPS` is minmally **8000** on **weekdays**.

```{r}
#| eval: false
flowLine_dest <- filter(flowLine, DESTIN_hex %in% hex_grid_bounded3$index)
dest_hex <- filter(hex_grid_bounded3, index %in% flowLine_dest$DESTIN_hex)

dest_hex_8000 <- dest_hex[dest_hex$index %in% flowLine_dest$DESTIN_hex[flowLine_dest$TOTAL_TRIPS >= 10000], ]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
tm_shape(dest_hex_8000) + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_dest %>%  
  filter(DAY_TYPE == "WEEKDAY", TOTAL_TRIPS >= 8000) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Destinations: Desire Lines with at least 8000 trips \nbetween Traffic Analysis Zones for Weekdays \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
  
```

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(3).png)

## Weekday vs Weekend/Holiday

This scenario simulates the user wanting to find out how do bus destinations differ on **weekends** compared to **weekdays**.

```{r}
#| eval: false
tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
tm_shape(dest_hex_8000) + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_dest %>%  
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY", TOTAL_TRIPS >= 8000) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Destinations: Desire Lines with at least 8000 trips \nbetween Traffic Analysis Zones for Weekends \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
  
```

-   Hexagons linked to desire lines reveal that they are more popular starting or destination locations for bus rides.

-   There are many trips made to destinations in the north, which is around Tuas Checkpoint.

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(4).png)

## Specific Hour of the Day

A user might be curious about bus traffic flows and where they start on weekdays at 8am.

```{r}
#| eval: false
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_grid_bounded3, index %in% flowLine_org$ORIGIN_hex)

org_hex_3000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 3000], ]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
tm_shape(org_hex_3000) + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%  
  filter(TOTAL_TRIPS >= 3000, TIME_PER_HOUR == 8) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Origin: Desire Lines Traffic Analysis Zones Weekdays, 8am \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
  
```

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(9).png)

Since too many desire lines are plotted, the user can narrow the minimum number of total trips per origin-destination hexagon pair to 10000.

```{r}
#| eval: false
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_grid_bounded3, index %in% flowLine_org$ORIGIN_hex)

org_hex_10000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 10000], ]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
tm_shape(org_hex_10000) + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%  
  filter(TOTAL_TRIPS >= 10000, TIME_PER_HOUR == 8) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Origin: Desire Lines between Traffic Analysis Zones with >10000 Trips \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
```

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(4).png)

# Level 2: Planning Area

The below scenario is whereby a user is interested in looking at bus trips starting from a Planning Area like Bedok at 8am on a weekday.

```{r}
#| eval: false
tmap_mode("view")
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_grid_bounded3, index %in% flowLine_org$ORIGIN_hex)

org_hex_3000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 3000], ]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
org_hex_3000 %>%
  filter(PLN_AREA_N == "BEDOK") %>%
tm_shape() + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%
  filter(ORIGIN_hex %in% org_hex_3000$index[org_hex_3000$PLN_AREA_N == "BEDOK"]) %>%  
  filter(TOTAL_TRIPS >= 3000, TIME_PER_HOUR == 8) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Bedok Origin: Desire Lines between Traffic Analysis Zones with >3000 Trips \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
```

-   The majority of bus trips at 8 am starting from Bedok Planning Area mostly end within the Planning Area too.

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(5).png)

Multiple starting planning areas for bus trips can also be observed.

```{r}
#| eval: false
tmap_mode("view")
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_grid_bounded3, index %in% flowLine_org$ORIGIN_hex)

org_hex_3000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 3000], ]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
org_hex_3000 %>%
  filter(PLN_AREA_N %in% c("BEDOK", "PUNGGOL", "PAYA LEBAR")) %>%
tm_shape() + 
  tm_fill(col = "PLN_AREA_N", palette = "Dark2", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%
  filter(ORIGIN_hex %in% org_hex_3000$index[org_hex_3000$PLN_AREA_N %in% c("BEDOK", "PUNGGOL", "PAYA LEBAR")]) %>%  
  filter(TOTAL_TRIPS >= 3000, TIME_PER_HOUR == 8) %>%
left_join(org_hex_3000 %>% distinct(index, PLN_AREA_N), by = c("ORIGIN_hex" = "index")) %>%
  tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           col = "PLN_AREA_N",
           palette = "Dark2",
           scale = c(1, 2, 3, 4, 5, 7, 9),
           alpha = 0.5
  ) + 
  tm_layout(main.title = "Bedok, Paya Lebar & Punggol Origin: Desire Lines between \nTraffic Analysis Zones with >3000 Trips (Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) +
tm_view(set.zoom.limits = c(12,30))
```

-   There are more origin locations at Bedok than Punggol at 8am.

-   There are noticeable outgoing bus trips from Punggol to Bedok Planning Area at 8am.

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(6).png)

# Level 3: Subzone

The user might also want to view bus travels at the subzone level, such as those starting from subzone Mathilda in Punggol planning area.

```{r}
#| eval: false
tmap_mode("plot")
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_grid_bounded3, index %in% flowLine_org$ORIGIN_hex)

org_hex_3000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 3000], ]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
org_hex_3000 %>%
  filter(SUBZONE_N == "MATILDA") %>%
tm_shape() + 
  tm_fill(col = "skyblue", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%
  filter(ORIGIN_hex %in% org_hex_3000$index[org_hex_3000$SUBZONE_N == "MATILDA"]) %>%  
  filter(TOTAL_TRIPS >= 3000, TIME_PER_HOUR == 7) %>%
tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           scale = c(1,2,3,4,5,7,9),
           n = 6, 
           alpha = 0.5,
           title.lwd = "Total Trips"
           ) + 
  tm_layout(main.title = "Punggol Matilda Origin: Desire Lines between Traffic Analysis Zones with >3000 Trips \n(Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) 
```

-   Between 7am and 8am, there are many trips from Matilda subzone to its immediate east hexagon neighbour that is also within the Punggol Planning Area.

Town Councils have recently been pushing for silver zones which promotes elderly-friendly paths along with school zones. Traffic calming in such zones may affect bus routes and it is important to check the volume of inter Planning Area bus routes. Planners can use the multiple-subzones perspective as a proxy of the potential economic costs of constructing such zones:

```{r}
#| eval: false
tmap_mode("view")
flowLine_org <- filter(flowLine, ORIGIN_hex %in% hex_grid_bounded3$index)
org_hex <- filter(hex_grid_bounded3, index %in% flowLine_org$ORIGIN_hex)

org_hex_3000 <- org_hex[org_hex$index %in% flowLine_org$ORIGIN_hex[flowLine_org$TOTAL_TRIPS >= 3000], ]

org_hex_3000 <- org_hex_3000[, c("index", setdiff(names(org_hex_3000), "index"))]

hex_grid_bounded3 <- hex_grid_bounded3[, c("index", setdiff(names(hex_grid_bounded3), "index"))]

tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
  tm_fill(col = "lightgrey", alpha = 0.2) +
org_hex_3000 %>%
  filter(SUBZONE_N %in% c("WATERWAY EAST", "NORTHSHORE", "MATILDA", "PUNGGOL FIELD", "CONEY ISLAND")) %>%
tm_shape() + 
  tm_fill(col = "SUBZONE_N", palette = "Dark2", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%
  filter(ORIGIN_hex %in% org_hex_3000$index[org_hex_3000$SUBZONE_N %in% c("WATERWAY EAST", "NORTHSHORE", "MATILDA", "PUNGGOL FIELD", "CONEY ISLAND")]) %>%  
  filter(DAY_TYPE == "WEEKDAY",TOTAL_TRIPS >= 3000, TIME_PER_HOUR == 7) %>%
left_join(org_hex_3000 %>% distinct(index, SUBZONE_N), by = c("ORIGIN_hex" = "index")) %>%
  tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           col = "SUBZONE_N",
           palette = "Dark2",
           scale = c(1, 2, 3, 4, 5, 7, 9),
           alpha = 0.5
  ) + 
  tm_layout(main.title = "Punggol Subzones Origin: Desire Lines between \nTraffic Analysis Zones with >3000 Trips (Nov '23 - Jan '24)",
            main.title.position = "center",
            main.title.size = 0.6,
            frame = TRUE) +
  tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) +
tm_view(set.zoom.limits = c(12,20))
```

::: callout-tip
-   On weekdays, 7-8am, there has been a high total bus traffic of 29,460 trips from Matilda (hex 1368) to Punggol Field (hex 1390), and 29,178 trips from Punggol Field (hex 1390) to Waterway East (hex 1412).

-   There is also high bus traffic of 14,581 trips within Punggol Field subzone, from hex 1390 to hex 1400. Should there be construction plans in these hexagonal areas, the relevant government agencies or even the town council can advice residents on alternative routes to go to their respective destinations.
:::

The potential user interface for the above scenario may look like this:

![](img/Commute%20Flow%20Map%20(7).png)

# Validating Spatial Interaction Models

As a teaser to SIMs, users can have a look at whether the volume of bus trips could be influenced by areas of interests within the vicinity.

From the previous map, we can see that there is a total high bus traffic of 14,581 from Punggol Field hex 1400 to Bedok North (hex 1515) from 7-8am on weekdays.

```{r}
#| eval: false
tmap_mode("view")
tm_shape(hex_grid_bounded3) +
  tm_borders(col = "grey") +
org_hex_3000 %>%
  filter(SUBZONE_N %in% c("WATERWAY EAST", "NORTHSHORE", "MATILDA", "PUNGGOL FIELD", "CONEY ISLAND")) %>%
tm_shape() + 
  tm_fill(col = "SUBZONE_N", palette = "Dark2", alpha = 0.5) +
  tm_borders(col = "grey") +
flowLine_org %>%
  filter(ORIGIN_hex %in% org_hex_3000$index[org_hex_3000$SUBZONE_N %in% c("WATERWAY EAST", "NORTHSHORE", "MATILDA", "PUNGGOL FIELD", "CONEY ISLAND")]) %>%  
  filter(TOTAL_TRIPS >= 3000, TIME_PER_HOUR == 7) %>%
left_join(org_hex_3000 %>% distinct(index, SUBZONE_N), by = c("ORIGIN_hex" = "index")) %>%
  tm_shape() +
  tm_lines(lwd = "TOTAL_TRIPS",
           col = "SUBZONE_N",
           palette = "Dark2",
           scale = c(1, 2, 3, 4, 5, 7, 9),
           alpha = 0.5
  ) + 
tm_shape(biz) +
  tm_dots(col = "blue") +
tm_layout(main.title = "Punggol Subzones Origin: Desire Lines between \nTraffic Analysis Zones with >3000 Trips (Nov '23 - Jan '24)",
          main.title.position = "center",
          main.title.size = 0.6,
          frame = TRUE) +
tm_legend(position = c("RIGHT", "BOTTOM"), legend.text.size = 0.4) +
tm_view(set.zoom.limits = c(12,20))
```

```{r}
#| eval: false
tmap_mode("plot")
```

::: callout-note
-   Perhaps on weekdays 8-9am, Bedok North hex 1515 is a popular destination for the population living in Punggol Field hex 1400 due to the numerous businesses in the former hex which is also an industrial area.
:::

![](img/Commute%20Flow%20Map%20(8).png)



#   References

M. Chan. Applied Spatial Interaction Models - Case Study of Singapore Public Bus Commuter Flows.
https://geospatial2023.netlify.app/take_home_exercise/ex2/take_home_ex2#calibrate-spatial-econometric-interaction-model-usng-maximum-likelihood-estimation

K. J. Paas, 2023. Take Home Exercise 2: A Case Study of Singapore Public Bus Commuter Flows.
https://isss624-kjcpaas.netlify.app/take-home_ex2/take-home_ex2

T. S. Kam. 

