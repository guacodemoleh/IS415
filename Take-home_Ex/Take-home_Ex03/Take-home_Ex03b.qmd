---
title: "Take-home Exercise 3 (Revised): Exploratory Spatial Data Analysis for Potential Push & Pull Factors of Locations in Singapore using Public Bus Data"
author: "Victoria Grace ANN"
execute: 
  warning: false
  eval: true
  echo: true
  freeze: true
format:  
  html: 
    code-summary: "Show the code"
    toc-depth: 4
date: "11 March, 2024"
date-modified: "last-modified"
editor: visual
---

# 1.0 Overview

In this exercise, my focus would be on prototyping exploratory spatial data analysis, particularly density of spatial assets within hexagonal traffic analysis zones. In conventional geography, a traffic analysis zone is the unit most commonly used in transportation planning models and the size of it varies. Hexagonal traffic analysis zones has gained traction as the hexagons of the study area have a uniform size which are easily comparable with each other when determining transport attractiveness. It is also recommended that hexagon radius should be 125m for areas in high urbanisation and 250m in areas with less urbanisation (Chmielewski et al., 2020).

The data preparation for this purpose also supports the preparation for calibrating spatial interaction models. For the prototyping, only exploratory spatial data analysis will be done.

# 2.0 Package Installation

I will load up the below R packages for the following purposes:

-   tmap: to visualise spatial data by creating thematic maps that could be interactive or static.

-   sf: to manipulate spatial data.

-   sp: to manipulate spatial data (older than sp).

-   reshape2: to reshape and transform data frames; converting data between "wide" and "long" formats using functions like melt().

-   ggplot2: to visualise data with plot types including bar plots.

-   tidyverse: to clean and transform data and contains sub-packagess including tidyr, dplyr and readr.

-   stplanr: to provide functions suitable for working with spatial transport data like networks, orgins-destinations matrices and travel time matrices; builds on the capabilities of sf and sp packages.

-   knitr: to combine code into a single documents that can be easily converted to various output formats like html, pdf, or Word.

-   kableExtra: to further style any Kables.

-   spdep: to create spatial wieght matrix objects from contiguities

-   spflow: to estimate spatial econometric interaction models

```{r}
pacman::p_load(tmap, sf, sp, reshape2, ggplot2, ggpubr, tidyverse, stplanr, knitr, kableExtra, spdep)

#devtools::install_github("LukeCe/spflow")
library(spflow)
```

# 3.0 Data sources

-   URA's Masterplan Subzone 2019 Layer in shapefile format

-   Bus Stop Locations extracted from LTA

-   A tabulated bus passenger flow for Nov 2023, Dec 2023 and Jan 2024 from LTA dynamic data mall

-   Population Data for 2023 from SingStat

-   Schools from MOE

-   Financial Services

-   Hospitals, polyclinics and CHAS clinics derived from Google Maps

# 4.0 Data preparation

# 4.1 Data preparation for bus-induced hexagons

::: panel-tabset


## Subzone Layer

Read the subzone layer

```{r}
#| eval: false
mpsz <- st_read("data/geospatial/master-plan-2019-subzone-boundary-no-sea-kml.kml")
```

Convert `mpsz` to 2D geometry.

```{r}
#| eval: false
mpsz <- st_zm(mpsz, drop = TRUE) # Convert 3D geometries to 2D
```

Extract the `SUBZONE_N` and `PLN_AREA_N` from the `Dscrptn` field

For SUBZONE_N,

```{r}
#| eval: false
mpsz <- mpsz %>%
  rowwise() %>%
  mutate(SUBZONE_N = str_extract(Description, "<th>SUBZONE_N</th> <td>(.*?)</td>")) %>%
  ungroup()

mpsz$SUBZONE_N <- str_remove_all(mpsz$SUBZONE_N, "<.*?>|SUBZONE_N")
```

For PLN_AREA_N,

```{r}
#| eval: false
mpsz <- mpsz %>%
  rowwise() %>%
  mutate(PLN_AREA_N = str_extract(Description, "<th>PLN_AREA_N</th> <td>(.*?)</td>")) %>%
  ungroup()

mpsz$PLN_AREA_N <- str_remove_all(mpsz$PLN_AREA_N, "<.*?>|PLN_AREA_N")
```

Remove the `Description` column.

```{r}
#| eval: false
mpsz$Description <- NULL
```

Remove unwanted outer islands.

```{r}
#| eval: false
mpsz3414 <- mpsz %>% st_transform(crs = 3414)

outer_islands <- c("SEMAKAU", "SUDONG", "NORTH-EASTERN ISLANDS", "SOUTHERN GROUP")
mpsz3414 <- mpsz3414 %>%
  filter(!str_trim(SUBZONE_N) %in% str_trim(outer_islands))
```

Create the shapefile.

```{r}
#| eval: false
st_write(mpsz3414, "data/geospatial/mpsz3414.shp", append=FALSE)
```

Read the updated shapefile.

```{r}
mpsz3414 <- st_read("data/geospatial/mpsz3414.shp") 
```

## Bus Stops Layer

Read the aspatial bus stop layer and set its CRS to 3414.

```{r}
BusStop <- read.csv("data/aspatial/bus_coords_subzone_v2.csv") %>% st_as_sf(coords=c("Longitude", "Latitude"), crs=4326) %>%
  st_transform(crs=3414)

summary(BusStop)
```

Ensure that all bus stops are within Singapore's boundary.

```{r}
BusStop <- BusStop %>% st_intersection(mpsz3414) %>% select(BusStopCode, )

tm_shape(mpsz3414) +
  tm_polygons() +
  tm_shape(BusStop) +
  tm_dots()
```

## Spatial Grids Layer

Generate the hexagon grids using `st_make_grid()` with a cellsize of 750m.

```{r}
hex_grids <- BusStop %>% st_make_grid(cellsize =750,
                                       what = "polygons",
                                       square = FALSE) %>%
  st_sf() %>%
  filter(lengths(st_intersects(geometry, BusStop)) > 0)
```


::: {.callout-tip collapse="true"}
### Code interpretation

-   st_make_grid: creates grids covering areas also without bus stops

-   cellsize: hexagon size determined by twice the length of the apothem

-   st_sf: set the hexagons as a sf object

-   filter: filtering for hexagons that contain bus stops

:::


Have a look and check if the hexagons cover all the bus stop locations.

```{r}
tm_shape(mpsz3414) +
  tm_polygons(title = "Singapore Boundary") +
  tm_shape(hex_grids) +
  tm_polygons(col = "white", title = "Hexagons", alpha = 1) +
  tm_layout(main.title = "Hexagons corresponding to Singapore bus stops",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_compass(type="8star", size = 2, bg.color = "white", bg.alpha = 0.5) +
  tm_scale_bar(bg.color = "white", bg.alpha = 0.5) +
  tm_shape(BusStop) +
  tm_dots(col = "red", size = 0.001, title = "Bus Stops") +
  tm_grid(alpha = 0.2)
```


### Assign ID to each hexagon

Each hexagon will have an assigned ID that will be their unique identifier. This new information can be stored under the HEX_ID column which will be helpful for joining data frames.

```{r}
#| eval: false
hex_grids$HEX_ID <- sprintf("H%04d", seq_len(nrow(hex_grids))) %>%
  as.factor()
```


::: {.callout-tip collapse="true"}
### Save the layer

```{r}
#| eval: false
write_rds(hex_grids, "data/rds/hex_grids.rds")
```

:::


```{r}
hex_grids <- read_rds("data/rds/hex_grids.rds")

kable(head(hex_grids))
```



# 4.2 Spatial Interaction Analysis


## Importing data sets

::: {.callout-note collapse="true"}
## Combining OD data

```{r}
#| eval: false
od_bus_nov <- read_csv("data/OD Bus/merged_bus_nov_v2.csv")
od_bus_dec <- read_csv("data/OD Bus/merged_bus_dec_v2.csv")
od_bus_jan <- read_csv("data/OD Bus/merged_bus_jan_v2.csv")
```

```{r}
#| eval: false
OD <- rbind(od_bus_nov, od_bus_dec)
OD <- rbind(OD, od_bus_jan)

nrow(od_bus_nov) + nrow(od_bus_dec) + nrow(od_bus_jan) == nrow(OD) # evaluates to TRUE
```

```{r}
#| eval: false
str(OD)
```

`ORIGIN_PT_CODE` and `DESTINATION_PT_CODE` are listed as character variables. These variables should be transformed to factors so that R treats them as grouping variables.

```{r}
#| eval: false
cols_to_convert <- c("ORIGIN_PT_CODE", "DESTINATION_PT_CODE")

OD[cols_to_convert] <- lapply(OD[cols_to_convert], as.factor)

glimpse(OD)
```

ORIGIN_PT_CODE`and`DESTINATION_PT_CODE\` are now factors.

```{r}
#| eval: false
write_rds(OD, "data/rds/odbus_combined.rds")
```

```{r}
#| eval: false
odbus_combined <- read_rds("data/rds/odbus_combined.rds")
```
:::

::: {.callout-note collapse="true"}
## Creating Commute Flow Data

```{r}
#| eval: false
od <- odbus_combined %>%
  group_by(ORIGIN_PT_CODE, ORIGIN_SUBZONE, DESTINATION_PT_CODE, DESTINATION_SUBZONE, DAY_TYPE ,TIME_PER_HOUR) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS)) %>%
  ungroup()

write_rds(od, "data/rds/od.rds")
```

```{r}
od <- read_rds("data/rds/od.rds")
```
:::



:::{.callout-note collapse="true"}
## Generating O-D trip data by hexagon level

We can create a lookup table for the bus stops associated to each hexagon.


## Generating lookup table for bus stop to associated hexagon

To connect the trip data to their corresponding hexagons, a lookup table needs to be made so that there is a relationship beetween the aspatial `od` and `hex_grids`.

```{r}
bs_hex <- st_intersection(BusStop, hex_grids) %>%
  st_drop_geometry() %>%
  select(c(BusStopCode, HEX_ID))

kable(head(bs_hex))
```


:::{.callout-warning}
### Multiple HEX_ID per bus stop
Some bus stops may fall in the boundary of neighbouring hexagons. To resolve this, such bus stops shall be assigned to the first identified corresponding HEX_ID.
:::

```{r}
bs_hex <- bs_hex %>%
  group_by(BusStopCode) %>%
  summarise(across(everything(), first)) %>%
  ungroup()

nrow(bs_hex) == nrow(BusStop)
```

:::


::: {.callout-note collapse="true"}
## Joining *od* and *bs_hex*

Associate the origin bus stops and destination bus stops to their corresponding hexagons.


```{r}
bs_hex$BusStopCode <- as.factor(bs_hex$BusStopCode)

od_trips_w_hex <- od %>%
  inner_join(bs_hex,
             by = c("ORIGIN_PT_CODE" = "BusStopCode")) %>%
  rename(ORIG_HEX_ID = HEX_ID) %>%
  inner_join(bs_hex,
             by = c("DESTINATION_PT_CODE" = "BusStopCode")) %>%
  rename(DEST_HEX_ID = HEX_ID)

kable(head(od_trips_w_hex))
```

:::

::: {,callout-warning collapse="true"}
### Save Data Memory Space

`od` is not needed anymore since the necessary data has been extracted, so we can offload it.

```{r}
rm(od)
```

:::


::: {.callout-note collapse="true"}

## Aggregating data by hexagon

Perform aggregations by `ORIGIN_HEX_ID` and `DEST_HEX_ID` to have an aggregated sum of trips by hexagon instead of bus stops.

```{r}
od_hex <- od_trips_w_hex %>%
  group_by(ORIG_HEX_ID, ORIGIN_SUBZONE ,DEST_HEX_ID, DESTINATION_SUBZONE, DAY_TYPE, TIME_PER_HOUR) %>%
  summarise(TRIPS = sum(TRIPS))

kable(head(od_hex))
```

:::


::: {.callout-tip collapse="true"}
### Save the layer

```{r}
write_rds(bs_hex, "data/rds/bs_hex.rds")
write_rds(od_hex, "data/rds/od_hex.rds")
```
:::


::: {.callout-note collapse="true:}
## Generating flow lines

```{r}
#| eval: false
od_hex <- od_hex[, c(1, 3, 2, 4:ncol(od_hex))]

flowlines <- od_hex %>% od2line(
  hex_grids,
  zone_code = "HEX_ID")

write_rds(flowlines, "data/rds/flowlines.rds")
```

::: callout-tip
### Learning Point

The flow data in the `od2line` function must have the origin and destination indexes in its first two columns.
:::


```{r}
flowlines <- read_rds("data/rds/flowlines.rds")
```


## Inspect flowlines

:::{.callout-warning collapse="false"}
### Large data size
The flowlines data is very large.

For all visualisations, the number of trips per flowline shown will be 3000 and above.
:::


```{r}
tm_shape(mpsz3414) +
  tm_polygons(title = "Singapore Boundary", alpha = 0.5) +
  
  tm_shape(hex_grids) +
  tm_polygons(col = "white", title = "Hexagons", alpha = 1) +
  
  tm_shape(flowlines[flowlines$TRIPS >= 3000,]) +
  tm_lines(lwd = "TRIPS",
           style = "quantile",
           col = "red",
           scale = c(0.1, 1, 3, 5, 7),
           title.lwd = "# of bus trips",
           alpha = 0.8) +
  
  tm_layout(main.title = "Overall Bus Passenger Flow for Weekdays)",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  
  tm_compass(type="8star", size = 2, bg.color = "white", bg.alpha = 0.5) +
  tm_scale_bar(bg.color = "white", bg.alpha = 0.5) +
  tm_grid(alpha = 0.2)
```


:::

:::{.callout-warning collapse="true"}
### Save Data Memory

```{r}
rm(flowlines)
rm(od_hex)
```

:::


# 4.2.1 Prototype for Spatial Interaction Analysis



# 5.0 Spatial Interaction Modelling

## 5.1.1 Attractiveness variables

Initiate the attractiveness from `hex_grids`.

```{r}
attractiveness <- hex_grids %>% st_set_crs(3414)
```


For all the variables, we only need to count the number of each location types per hexagon, which can be done using `lengths()` and `st_intersects()`.

### POIs

::: panel-tabset

### Bus Stops

```{r}
attractiveness$BUS_STOP_COUNT <- lengths(
  st_intersects(attractiveness, BusStop))
```

### Entertainment

```{r}
entertn <- st_read("data/geospatial/entertn.shp") %>% st_set_crs(3414)
```

```{r}
attractiveness$ENTERTN_COUNT <- lengths(st_intersects(attractiveness, entertn))
```


### F&B

```{r}
food_bev <- st_read("data/geospatial/F&B.shp") %>% st_set_crs(3414)
```

```{r}
attractiveness$FOOD_BEV_COUNT <- lengths(st_intersects(attractiveness, food_bev))
```

### Leisure & Recreation

```{r}
leis_rec <- st_read("data/geospatial/Liesure&Recreation.shp") %>% st_set_crs(3414)
```

```{r}
attractiveness$LEISURE_COUNT <- lengths(st_intersects(attractiveness, leis_rec))
```


### Retail

```{r}
retail <- st_read("data/geospatial/Retails.shp") %>% st_set_crs(3414)
```

```{r}
attractiveness$RETAIL_COUNT <- lengths(st_intersects(attractiveness, retail))
```


### Business

```{r}
biz <- st_read("data/geospatial/Business.shp") %>% st_set_crs(3414)
```

```{r}
attractiveness$BIZ_COUNT <- lengths(st_intersects(attractiveness, biz))
```


### Financial Services

```{r}
fin <- st_read("data/geospatial/FinServ.shp") %>% st_set_crs(3414)
```

```{r}
attractiveness$FIN_COUNT <- lengths(st_intersects(attractiveness, fin))
```


### Housing Population Proxies

::: {.callout-note collapse="true"}

#### Data preparation

```{r}
hdb <- read_csv("data/aspatial/hdb.csv")
```


For the purpose of computing a proxy for population density, the residential units will be extracted using *filter()* from the **dplyr** package.

```{r}
hdb_residential <- hdb %>%
  filter(residential == "Y")

head(hdb_residential, 10)
```

There are also some outliers like hotels that are classified as a residential unit. We can remove rows containing 'hotel' using *grepl()*.

```{r}
hotels <- hdb_residential %>%
  filter(grepl("HOTEL", building, ignore.case = TRUE))

kable(hotels)
```

The HDB Blk 1 Beach Road shares a similar address as Raffles Hotel's 1 Beach Road, but they have different postal codes.

To verify other similar addresses, filter for addresses containing "BEACH RD".

```{r}
beach_rd <- hdb_residential %>%
  filter(grepl("BEACH RD", street, ignore.case = TRUE))

kable(beach_rd)
```

2, 5 and 15 Beach Road do not have the correct postal codes following the 1900XX convention. Additionally, these addresses do not have the correct coordinates too.

With reference to URA's official asset map of Singapore, OneMap, the data will be manually modified using *mutate()* and *ifelse()*.

```{r}
hdb_residential2 <- hdb_residential %>%
  mutate(postal = ifelse(blk_no == 1 & street == "BEACH RD", 190001, postal)) %>%
  mutate(lat = ifelse(blk_no == 1 & street == "BEACH RD", 1.3036714, lat)) %>%
  mutate(lng = ifelse(blk_no == 1 & street == "BEACH RD", 103.8644787, lng)) %>%
  mutate(postal = ifelse(blk_no == 2 & street == "BEACH RD", 190002, postal)) %>%
  mutate(lat = ifelse(blk_no == 2 & street == "BEACH RD", 1.3040331, lat)) %>%
  mutate(lng = ifelse(blk_no == 2 & street == "BEACH RD", 103.8649285, lng)) %>%
  mutate(postal = ifelse(blk_no == 3 & street == "BEACH RD", 190003, postal)) %>%
  mutate(lat = ifelse(blk_no == 3 & street == "BEACH RD", 1.3041872, lat)) %>%
  mutate(lng = ifelse(blk_no == 3 & street == "BEACH RD", 103.8651934, lng)) %>%
  mutate(postal = ifelse(blk_no == 5 & street == "BEACH RD", 190005, postal)) %>%
  mutate(lat = ifelse(blk_no == 5 & street == "BEACH RD", 1.3043463, lat)) %>%
  mutate(lng = ifelse(blk_no == 5 & street == "BEACH RD", 103.8648158, lng)) %>%
  mutate(postal = ifelse(blk_no == 15 & street == "BEACH RD", 190015, postal)) %>%
  mutate(lat = ifelse(blk_no == 15 & street == "BEACH RD", 1.3034254, lat)) %>%
  mutate(lng = ifelse(blk_no == 15 & street == "BEACH RD", 103.8631535, lng))
```

Check for any duplicates.

```{r}
duplicate <- hdb_residential2 %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()

DT::datatable(duplicate)
```

```{r}
hdb_residential2 <- st_as_sf(hdb_residential2, coords = c("lng","lat"), crs=4326) 

hdb_residential2 <- st_transform(hdb_residential2, crs=3414)
```

:::


```{r}
attractiveness$HDB_COUNT <- lengths(st_intersects(attractiveness, hdb_residential2))
```


::: {.callout-warning collapse}

#### Save Memory Space by Offloading

```{r}
rm(hdb)
rm(hdb_residential)
```

:::


### Public Healthcare 

#### Data Preparation

```{r}
#| eval: false
public_hc <- read_csv("data/aspatial/HospitalsPolyclinics v_2024.csv")

public_hc.sf <- st_as_sf(public_hc[1:42,], wkt = "geometry", crs = 4326) %>% 
  st_transform(crs=3414)

public_hc2.sf <- st_as_sf(public_hc[43:1235,], wkt = "geometry", crs = 3414) # CHAS clinics encoded in EPSG 3414 

public_hc.sf <- rbind(public_hc.sf, public_hc2.sf)

write_rds(public_hc.sf, "data/rds/public_hc.rds")
```

```{r}
hc <- read_rds("data/rds/public_hc.rds")
```


```{r}
attractiveness$HC_COUNT <- lengths(st_intersects(attractiveness, hc))
```

### School


```{r}
#| eval: false
schools <- read_csv("data/aspatial/schoolsclean.csv")

schools <- schools %>%
  separate(latlong, into = c("latitude", "longitude"), sep = ",", convert = TRUE)

schools_sf <- st_as_sf(schools, coords = c("longitude","latitude"), crs = 4326) %>% 
  st_transform(crs=3414)

write_rds(schools_sf, "data/rds/schools.rds")
```

::: {.callout-note collapse}

#### Save Memory Space by Offloading

```{r}
#| eval: false
rm(schools_sf)
```

:::

```{r}
schools <- read_rds("data/rds/schools.rds")
```

```{r}
attractiveness$SCH_COUNT <- lengths(st_intersects(attractiveness, schools))
```

:::


Check attractiveness variables have been added correctly.

```{r}
kable(head(attractiveness))
```

::: {.callout-tip collapse="true"}

```{r}
write_rds(attractiveness, "data/rds/attractiveness.rds")
```

:::


::: {.callout-warning collapse="true"}
```{r}
rm(hotels)
```
:::


## 5.1.2 Deriving Passengers  Alighting from Bus Stop

Aggregate the trips using `inner_join()`, `group_by()` and `summarise()`.

```{r}
dest_bus_hex <- od_trips_w_hex %>%
  inner_join(bs_hex,
             by = join_by(DESTINATION_PT_CODE == BusStopCode)) %>%
  group_by(HEX_ID) %>%
  summarise(TRIPS = sum(TRIPS))

kable(head(dest_bus_hex))
```


:::{.callout-tip collapse="true"}
### Why use inner join?

-   An inner join returns only the rows that have matching values in both tables based on the specified join condition.

-   It discards unmatched rows from both the left and right tables.

-   The result set contains only the rows where the join condition is satisfied.

-   Rows from either table that do not have a match in the other table are excluded from the result.
:::


:::{.callout-tip collapse="true"}
### Save the layer

```{r}
write_rds(dest_bus_hex, "data/rds/dest_bus_hex.rds")
```

:::


:::{.callout-warning collapse="true"}
### Save Data Memory Space

```{r}
rm(bs_hex)
```

:::


## 5.2.1 Propulsiveness variables

```{r}
propulsiveness <- hex_grids
```


```{r}
propulsiveness <- propulsiveness %>%
  left_join(st_drop_geometry(dest_bus_hex)) %>%
  rename(BUS_ALIGHT_COUNT = TRIPS)

kable(head(propulsiveness))
```


```{r}
propulsiveness[is.na(propulsiveness)] <- 0
kable(head(propulsiveness))
```


:::{.callout-tip collapse="true"}
### Save the layer

```{r}
write_rds(propulsiveness, "data/rds/propulsiveness.rds")
```

:::


## 5.3 Generating distance table

### Generating distance matrix

We can use `spDists()` to generate the distance matrix from the hex_grids layer. The column and row names need to be renamed according to the corresponding `HEX_ID`s.

```{r}
dist_mat <- spDists(as(hex_grids, "Spatial"),
                    longlat = FALSE)

colnames(dist_mat) <- paste0(hex_grids$HEX_ID)
rownames(dist_mat) <- paste0(hex_grids$HEX_ID)

kable(head(dist_mat, n=c(10,10)))
```

:::{.callout-tip}
Notice that the distance between adjacent centroids are 750m.
:::


### Generating a pivot table

```{r}
dist_tbl <- melt(dist_mat) %>%
  rename(DISTANCE = value) %>%
  rename(ORIG_HEX_ID = Var1) %>%
  rename(DEST_HEX_ID = Var2)
kable(head(dist_tbl))
```

Logically, intra-zonal distances are 0. This occurs when bus passengers are commuting to bus stops along the bus route that are within the same hexagon from where the passenger boarded the bus.

However, distances cannot be kept to 0 since we are going to conduct log-based Poisson regression modelling for spatial interaction modelling. Specifically, log(0) is undefined.

A reasonable replacement of the zero values would be 200m, assuming that the shortest distance between two consecutive bus stops is 200m. 

Setting intra-zonal distances to 200m,

```{r}
dist_tbl$DISTANCE[dist_tbl$ORIG_HEX_ID == dist_tbl$DEST_HEX_ID] <- 200
summary(dist_tbl$DISTANCE)
```

:::{.callout-tip collapse="true"}
### Save the layer

```{r}
write_rds(dist_tbl, "data/rds/dist_tbl.rds")
```

:::


:::{.callout-tip collapse="true"}
### Save Data Memory Space by offloading

```{r}
rm(dist_mat)
```

:::



# 6.0 Data Consolidation

Load the necessary data

```{r}
hex_grids <- read_rds("data/rds/hex_grids.rds")
flowlines <- read_rds("data/rds/flowlines.rds")
dist_tbl <- read_rds("data/rds/dist_tbl.rds")
attractiveness <- read_rds("data/rds/attractiveness.rds")
propulsiveness <- read_rds("data/rds/propulsiveness.rds")
```


Generating the consolidated geospatial data will require the following columns:

-   `ORIG_HEX_ID`: ID corresponding to the origin zone

-   `DEST_HEX_ID`: ID corresponding to the destination zone

-   `DISTANCE`: Distance between the (centroids of) origin and destination zones

-   `TRIPS`: Number of bus trips between the origin and destination zones

-   `DEST_*_COUNT`: Values from [Attractiveness Variables Table (attractiveness)]

-   `ORIG_*_COUNT`: Values from [Propulsiveness Variables Table (propulsiveness)]

-   Geometry defining flowlines


Now proceed to join the tables!

::: panel-tabset

## Flowlines

```{r}
kable(head(flowlines))
```

```{r}
#| eval: false
od_hex2 <- od_trips_w_hex %>%
  group_by(ORIG_HEX_ID, DEST_HEX_ID) %>%
  summarise(TRIPS = sum(TRIPS))

flowlines2 <- od_hex2 %>% od2line(
  hex_grids,
  zone_code = "HEX_ID")

SIM_data <- flowlines2 %>% 
  group_by(ORIG_HEX_ID, DEST_HEX_ID) %>%
  summarise(TRIPS = sum(TRIPS))
```

## Distance

```{r}
#| eval: false
SIM_data <- SIM_data %>% left_join(dist_tbl)
```


## Propulsive

Propulsive zones originate from origins so `propulsiveness` will join with `SIM_data` with the unique identifier as `ORIG_HEX_ID`. The `ORIG_` prefix will be added in by `propulsiveness`.

```{r}
#| eval: false
SIM_data <- left_join(
  SIM_data,
  propulsiveness %>%
    st_drop_geometry() %>%
    rename_with(~paste("ORIG_", .x, sep = ""))
  )
```


## Attractive

Attractive zones originate from destinations so `attractiveness` will join with `SIM_data` with the unique identifier as `DEST_HEX_ID`. The `DEST_` prefix will be added in by `propulsiveness`.

```{r}
#| eval: false
SIM_data <- left_join(
  SIM_data,
  attractiveness %>%
    st_drop_geometry() %>%
    rename_with(~paste("DEST_", .x, sep= ""))
)


write_rds(SIM_data, "data/rds/SIM_data.rds")
```


:::

## Finishing Touches

```{r}
SIM_data <- read_rds("data/rds/SIM_data.rds")
summary(SIM_data)
```



For the data to be compatible with modelling, we can change the zeroes to 0.99.

```{r}
replace_zeroes <- function(data, col_name) {
  data[[col_name]][data[[col_name]] == 0] <- 0.99
  data
}

SIM_data <- SIM_data %>%
  replace_zeroes("ORIG_BUS_ALIGHT_COUNT") %>%
  replace_zeroes("DEST_ENTERTN_COUNT") %>%
  replace_zeroes("DEST_FOOD_BEV_COUNT") %>%
  replace_zeroes("DEST_LEISURE_COUNT") %>%
  replace_zeroes("DEST_RETAIL_COUNT") %>%
  replace_zeroes("DEST_BIZ_COUNT") %>%
  replace_zeroes("DEST_FIN_COUNT") %>%
  replace_zeroes("DEST_HC_COUNT") %>%
  replace_zeroes("DEST_SCH_COUNT") %>%
  replace_zeroes("DEST_HDB_COUNT")

summary(SIM_data)
```


:::{.callout-tip collapse="true"}
### Save the layer

```{r}
#| eval: false
write_rds(SIM_data, "data/rds/SIM_data_final1.rds")
```

:::

# 7.0 Visualising Spatial Interactions


Load relevant datasets.

```{r}
mpsz3414 <- st_read("data/geospatial/mpsz3414.shp")
hex_grids <- read_rds("data/rds/hex_grids.rds")
flowlines <- read_rds("data/rds/flowlines.rds")
SIM_data <- read_rds("data/rds/SIM_data_final1.rds")
propulsiveness <- read_rds("data/rds/propulsiveness.rds")
attractiveness <- read_rds("data/rds/attractiveness.rds")
```



## General view

Since the flowlines dataset is large, remove the intra-zonal flows.

```{r}
flowlines_no_intra <- flowlines %>%
  filter(ORIG_HEX_ID != DEST_HEX_ID)
```


Then we can use `quantile()` to check the appropriate cut-off numbers.

```{r}
quantile(flowlines_no_intra$TRIPS,
         probs = c(0.8, 0.9, 0.95, 0.99, 1))
```

Showing the top 1% of these flow lines will reveal important details as they take up the majority of the bu trips that occurred from November 2023 to January 2024.

```{r}
flowlines_base <- filter(flowlines_no_intra, flowlines_no_intra$TRIPS>=2386)
```


```{r}
tm_shape(mpsz3414) +
  tm_polygons("lightgrey",title="Singapore Boundary", alpha = 0.8) +
  
  tm_shape(hex_grids) +
  tm_polygons("white", title="Hexagons", alpha=1) +
  
  tm_shape(flowlines_base) +
  tm_lines(lwd="TRIPS",
           style = "quantile",
           col = "red",
           scale = c(0.1, 1, 3, 5, 7),
           title.lwd = "# of bus trips",
           alpha = 0.8) +
  
  tm_layout(main.title = "Top 1% Bus Passenger flows",
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  
  tm_compass(type="8star", size = 2, bg.color = "white", bg.alpha = 0.5) +
  tm_scale_bar(bg.color = "white", bg.alpha = 0.5) +
  tm_grid(alpha = 0.2)
```




# Plotting TRIPS vs DISTANCE


```{r}
ggplot(SIM_data,
       aes(x = DISTANCE, y = TRIPS)) +
  geom_point() +
  geom_hline(yintercept = 2386, color = "red", linetype = "dashed") +
  annotate("text", x = 20000,
           y = 600, label = "95th percentile",
           hjust = -0.1, color = "red", size = 3) +
  geom_hline(yintercept = 1510, color = "purple", linetype = "dashed") +
  annotate("text", x = 20000,
           y = 1800, label = "99th percentile",
           hjust = -0.1, color = "purple", size = 3) +
  labs(title = "Number of Trips as a Function of Distance",
       x = "Distance (m)",
       y = "Number of Trips")
```


```{r}
ggplot(SIM_data,
       aes(x = log(DISTANCE), y = log(TRIPS))) +
  geom_point() +
  geom_smooth(method = lm)
```



## Visualising propulsive forces

::: {callout-tip collapse="true"}
### Creating a helper function

```{r}
plot_propulsive <- function(var_name, title_comp, day_type = NULL, hour = NULL, pa=NULL) {
  flowlines_filtered <- flowlines_no_intra
  
  if (!is.null(day_type)) {
    flowlines_filtered <- flowlines_filtered %>% filter(DAY_TYPE == day_type)
  }
  
  if (!is.null(hour)) {
    flowlines_filtered <- flowlines_filtered %>% filter(TIME_PER_HOUR == hour)
  }
  
  if (!is.null(pa)) {
    flowlines_filtered <- flowlines_filtered %>% filter(ORIGIN_SUBZONE == pa)
  }
  
  tm_shape(mpsz3414) +
  tm_polygons("lightgrey", title = "Singapore Boundary") +
  
  # Adding this layer underneath propulsiveness as we removed 0s. from the map
  # so it won't skew the legend
  tm_shape(hex_grids) +
  tm_polygons(col = "white") +
  
  tm_shape(propulsiveness %>% filter(if_any(var_name, ~. >= 1))) +
  tm_polygons(var_name, palette = "Blues", style = "quantile") +
    
  tm_shape(flowlines_no_intra %>% filter(TRIPS > 2385)) +
  tm_lines(lwd = "TRIPS",
           style = "quantile",
           col = "red",
           scale = c(0.1, 1, 3, 5, 7, 10),
           title.lwd = "# of bus trips",
           n = 6,
           alpha = 0.5) +
  
  tm_layout(main.title = paste("Top 1% Bus Passenger Flows and", title_comp),
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  
  tm_scale_bar(bg.color = "white", bg.alpha = 0.7, position = c("right", "top")) +
  tm_compass(type="8star", size = 2, bg.color = "white",
             bg.alpha = 0.5, position = c("right", "top")) +
  tm_grid(alpha = 0.2) +
  tm_credits("*Passenger data",
             bg.color = "white", bg.alpha = 0.7,
             position = c("left", "bottom"))
}
```

:::


Looking at transfers from Buses.

```{r}
plot_propulsive("BUS_ALIGHT_COUNT", "Potential Transfers from Bus")
```


## Visualising attractive forces

::: {callout-tip collapse="true"}
### Creating a helper function

```{r}
plot_attractive <- function(var_name, title_comp, day_type = NULL, hour = NULL, pa = NULL) {
  flowlines_filtered <- flowlines_no_intra
  
  if (!is.null(day_type)) {
    flowlines_filtered <- flowlines_filtered %>% filter(DAY_TYPE == day_type)
  }
  
  if (!is.null(hour)) {
    flowlines_filtered <- flowlines_filtered %>% filter(TIME_PER_HOUR == hour)
  }
  
  if (!is.null(pa)) {
    flowlines_filtered <- flowlines_filtered %>% filter(DESTINATION_SUBZONE == pa)
  }
  
  tm_shape(mpsz3414) +
  tm_polygons("green", title = "Singapore Boundary") +
  
  # Adding this layer underneath attractiveness as we removed 0s. from the map
  # so it won't skew the legend
  tm_shape(hex_grids) +
  tm_polygons(col = "white") +
  
  tm_shape(attractiveness %>% filter(if_any({{var_name}}, ~. >= 1))) +
  tm_polygons({{var_name}}, palette = "Purples", style = "quantile") +
    
  tm_shape(flowlines_filtered %>% filter(TRIPS > 2385)) +
  tm_lines(lwd = "TRIPS",
           style = "quantile",
           col = "red",
           scale = c(0.1, 1, 3, 5, 7, 10),
           title.lwd = "# of bus trips",
           n = 6,
           alpha = 0.5) +
  
  tm_layout(main.title = paste("Top 1% Bus Passenger Flows and", {{title_comp}}),
            main.title.position = "center",
            main.title.size = 1.0,
            legend.height = 0.35, 
            legend.width = 0.35,
            frame = TRUE) +
  
  tm_scale_bar(bg.color = "white", bg.alpha = 0.7, position = c("right", "top")) +
  tm_compass(type="8star", size = 2, bg.color = "white",
             bg.alpha = 0.5, position = c("right", "top")) +
  tm_grid(alpha = 0.2) +
  tm_credits("*Passenger data",
             bg.color = "white", bg.alpha = 0.7,
             position = c("left", "bottom"))
}
```

:::


::: panel-tabset

### Bus Stops
```{r}
plot_attractive("BUS_STOP_COUNT", "Number of Bus Stops")
```

### HDBs
```{r}
plot_attractive("HDB_COUNT", "Number of HDB Blocks")
```

### Businesses
```{r}
plot_attractive("BIZ_COUNT", "Number of Business Locations", day_type = "WEEKENDS/HOLIDAY")
```

### Entertainment
```{r}
plot_attractive("ENTERTN_COUNT", "Number of Entertainment \nLocations at 5pm on Weekdays", day_type = "WEEKDAY", hour=17)
```

### F&B
```{r}
plot_attractive("FOOD_BEV_COUNT", "Number of F&B Locations", pa = "BEDOK")
```

### Leisure
```{r}
plot_attractive("LEISURE_COUNT", "Number of Leisure \n& Recreation Spots attracting flows to Bedok and Paya Lebar", pa = c("BEDOK", "PAYA LEBAR"))
```

### Retail
```{r}
plot_attractive("RETAIL_COUNT", "Number of Retail Locations at 1pm", hour = 13)
```

### Financial Services
```{r}
plot_attractive("FIN_COUNT", "Number of Financial Service Locations")
```

### Public Healthcare Services
```{r}
plot_attractive("HC_COUNT", "Number of Public Healthcare Spots")
```

### School
```{r}
plot_attractive("SCH_COUNT", "Number of School Locations")
```

:::

# 7.1 Prototype Potential

The user inputs will include:

-   Flow direction with the choices of `Overall`, `Outgoing`, `Incoming`

-   A viewing level drop-down bar with choices of `Overall`, `PLN_AREA`. If `PLN_AREA` is selected, there will be a further drp-down feature for the user to select the interested planning areas of the Origins and Destinations.

-   Day type with the choices of `Overall`, `WEEKDAY`, `WEEKENDS/HOLIDAYS`

-   Time hour choice in a sliding bar style, ranging from 0 to 23.

-   A sliding bar to control the number of trips shown based on the user inputs



# 8.0 Spatial Econometric Interaction Modelling





Remove the intra-zonal zones pairs from SIM_data.

```{r}
SIM_data_no_intra <- SIM_data %>% filter(ORIG_HEX_ID != DEST_HEX_ID)
```



To calibrate SEIM using spflow package, three data sets are required:

-   Spatial Weights

-   Distance Matrix

-   Explanatory Variables


## Prepare Spatial Weights

```{r}
mpsz3414 <- st_read("data/geospatial/mpsz3414.shp")

hex_grid <- st_make_grid(mpsz3414, cellsize = c(750, 750), what = "polygons", square = FALSE) %>%
  st_sf() %>%
  # Apply as.factor() since index will be used as the identifier to link to other data sets
  mutate(index = as.factor(row_number()))

# Create border of Singapore's land area
mpsz_border <- mpsz3414 %>% st_union()

# Clip the hexagon grid layer
hex_grid_bounded <- st_intersection(hex_grid, mpsz_border)

# Check if hex grid intersects any polygons using st_intersects
# Returns a list of intersecting hexagons
intersection_list = hex_grid$index[lengths(st_intersects(hex_grid, hex_grid_bounded)) > 0]

# Filter for the intersecting hexagons
hex_grids = hex_grid %>%
  filter(index %in% intersection_list)


hex_grids$BUS_COUNT <- lengths(st_intersects(hex_grids, BusStop))
hex_grids$ENTERTN_COUNT <- lengths(st_intersects(hex_grids, entertn))
hex_grids$FOOD_BEV_COUNT <- lengths(st_intersects(hex_grids, food_bev))
hex_grids$LEISURE_COUNT <- lengths(st_intersects(hex_grids, leis_rec))
hex_grids$RETAIL_COUNT <- lengths(st_intersects(hex_grids, retail))
hex_grids$BIZ_COUNT <- lengths(st_intersects(hex_grids, biz))
hex_grids$FIN_COUNT <- lengths(st_intersects(hex_grids, fin))
hex_grids$HDB_COUNT <- lengths(st_intersects(hex_grids, hdb_residential2))
hex_grids$HC_COUNT <- lengths(st_intersects(hex_grids, hc))
hex_grids$SCHOOL_COUNT <- lengths(st_intersects(hex_grids, schools))


tm_shape(hex_grids) +
  tm_fill(col = "BUS_COUNT",
          palette = "Blues",
          style = "cont",
          title = "Bus Stop Density") +
  tm_borders(col="grey")
```


```{r}
coords <- hex_grids %>%
  filter("BUS_COUNT" > 0) %>%
  select(geometry) %>%
  st_centroid()

k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = FALSE))

# Print summary report
summary(k1dists)
```

The largest first nearest neighbour distance is 2461.2.

```{r}
centroids <- suppressWarnings({
    st_point_on_surface(st_geometry(hex_grids))})

hexgrid_nb <- list(
  "by_contiguity" = poly2nb(hex_grids),
  "by_distance" = dnearneigh(centroids, 
                             d1 = 0, d2 = 3437),
  "by_knn" = knn2nb(knearneigh(centroids, 6))
)

hexgrid_nb
```



## Preparing Flow Data


```{r}
#| eval: false
flowlines$DISTANCE <- dist_tbl$DISTANCE[match(paste(flowlines$ORIG_HEX_ID, flowlines$DEST_HEX_ID), paste(dist_tbl$ORIG_HEX_ID, dist_tbl$DEST_HEX_ID))]

flow_data <- flowlines %>%
  select(ORIG_HEX_ID, DEST_HEX_ID, TRIPS, DISTANCE) %>%
  group_by(ORIG_HEX_ID, DEST_HEX_ID, DISTANCE) %>%
  summarise(TRIPS = sum(TRIPS)) %>%
  ungroup()

write_rds(flow_data, "data/rds/flow_data_3b.rds")
```

```{r}
flow_data <- read_rds("data/rds/flow_data_3b.rds")
```


## Preparing Explanatory Variables


````{r}
explanatory <- hex_grids %>%
  st_drop_geometry()

write_rds(explanatory, "data/rds/explanatory.rds")

explanatory <- read_rds("data/rds/explanatory.rds")
```


## Creating spflow_network-class objects

```{r}
hex_net <- spflow_network(
  id_net = "sg",  # assign an id name, can give it any input
  node_neighborhood = nb2mat(hexgrid_nb$by_distance),
  node_data = explanatory,
  node_key_column = "index"
)

hex_net
```

Create spflow_network_pair-class using `spflow_network_pair()`

```{r}
#| eval: false
hex_net_pairs <- spflow_network_pair(
  id_orig_net = "sg",
  id_dest_net = "sg",
  pair_data = flow_data,
  orig_key_column = "ORIG_HEX_ID",
  dest_key_column = "DEST_HEX_ID"
)

hex_net_pairs
```


```{r}
#| eval: false
hex_multi_net <- spflow_network_multi(hex_net, hex_net_pairs)

hex_multi_net
```






# References

M. Chan. Applied Spatial Interaction Models - Case Study of Singapore Public Bus Commuter Flows. https://geospatial2023.netlify.app/take_home_exercise/ex2/take_home_ex2#calibrate-spatial-econometric-interaction-model-usng-maximum-likelihood-estimation

K. J. Paas, 2023. Take Home Exercise 2: A Case Study of Singapore Public Bus Commuter Flows. https://isss624-kjcpaas.netlify.app/take-home_ex2/take-home_ex2

T. S. Kam.
