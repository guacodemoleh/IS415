---
title: "Hands-on Exercise 9" 
author: "Victoria Grace ANN"
execute: 
  warning: false
date: "10 March, 2024"
date-modified: "last-modified"
---

# Install required packages

```{r}
pacman::p_load(spdep, tmap, sf, ClustGeo, ggpubr, cluster, factoextra, NbClust, heatmaply, corrplot, psych, tidyverse, GGally)
```


# Imports
## Geospatial data

Read the Myanmar Township Boundary shapefile using *st_read()*.

```{r}
shan_sf <- st_read(dsn="data/geospatial", layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```


To view the simple feature data frame, 

```{r}
glimpse(shan_sf)
```


## Aspatial data

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```


To view the summary statistics of `ict`,

```{r}
summary(ict)
```


## New variables using dplyr

To address the association bias due to the aggregated number of households in Shan state, we need to create the penetrationrates for each ICT variable.

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```


Review the summary statistics of the newly derived penetration rates.

```{r}
summary(ict_derived)
```
-   Six new fields  RADIO_PR, TV_PR, LLPHONE_PR, MPHONE_PR, COMPUTER_PR, and INTERNET_PR.


# Exploratory Data Analysis

## Histogram

We can use a histogram to observe the overall distribution of the households with radio.

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```
-   A left-skewed histogram signifies that there are fewer households with more radios relative to most households.

Then use a boxplot to detect if there are any outliers!

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```


Now plot the distribution for the radio penetration rate.

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```


The outliers can be plotted as such.
```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```


For a better overview, we can build a collage of histograms for the various penetration rates.

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```


The key function to build the collage will be *ggarrange()*.

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```


## Choropleth map

We need to collate the aspatial penetration rates and join them into our geospatial data.

```{r}
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
```

-   TS_PCODE, the postal code, is the common identifier used to perform the left-join.

```{r}
#| eval: false
write_rds(shan_sf, "data/rds/shan_sf.rds")
```


A quick view of the choropleth map can be performed using *qtm()*.

```{r}
qtm(shan_sf, "RADIO_PR")
```


The problem with the above map is that it is subjected to the bias to the total number of households. This bias can be verified by comparing the total number of households per town and the total number of households with radios.

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

-   As we can see, the choropleth maps show that townships with more households tend to have more radio ownership.

As such, let's compare the distribution fo total number of households and the radio penetration rate.

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

-   Less densely populated towns may have higher radio penetration rates.


# Correlation analysis

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```


# Hierarchy Cluster Analyssis

## Extracting cluster variables

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

Change the rows by township name.

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```

Delete the TS.x field.
```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```


## Data standardisation

Data standardisation is important to avoid biases in clustering.

## Min-Max standardisation

From *heatmaply*, *normalize()* is used for standardisation of clustering variables using the Min-Max method.
```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```


## Z-score standardisation

Z-score standardisation can be performed using *scale()*.

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```


## Visualising the standardised clustering variables

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

