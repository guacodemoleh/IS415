---
title: "Hands-on Exercise 3: Spatial Point Patterns Analysis"
author: "Victoria Grace ANN"
execute: 
  warning: false
  eval: true
  echo: true
format:  
  html: 
    code-fold: true
    code-summary: "Show the code"
    toc-depth: 4
date: "16 January, 2024"
date-modified: "last-modified"
editor: visual
---


# Lecture on Spatial Point Pattern Analysis

Spatial point patterns can be seen through many events and they are not limited to human activities. When there is data captured from a location, it can be considered as a spatial point. Such spatial points help analysts to observe any statistical patterns that are significant. In this context, we will only consider the points to be on isotropic (flat) planes.

Spatial point patterns exist in a Euclidean space which is in a 2-dimensional space. When the arrangement of the points is non-random, there should be underlying factors causing it.

## Spatial Point Pattern Analysis Techniques

### First-order

-   Expected values of spatial point patterns vary across space, like the intensity of spatial point pattern

*Kernel Density*

-   Depending on how points you want to capture, the *bandwidth* can be adjusted, i.e Adaptive bandwidth

-   When data is sparse, we can consider Fixed bandwidth

*Quadrat Analysis*

-   Used more frequently in Ecology

-   Count the frequency of events in each region thencalculate the intensity of events in each region

-   Variance-Mean Ratio (VMR)

    -   Uniform distribution, VMR \~ 0

    -   Random distribution, VMR \~ 1

    -   Cluster distribution, VMR \> 1

### Second-order

-   Covariance and correlation between spatial points of different regions

-   Measured using G, K and L function.

*Nearest Neighbour Index (NNI)*

-   Random distribution when Mean Distance \~ 1

-   Clustered distribution when Mean Distance \~ 0

-   Uniformed distribution when Mean Distance \> 1

# 1st Order Spatial Point Patterns Analysis

[*spatstat*](https://cran.r-project.org/web/packages/spatstat/) is an open-source toolbox for analysing spatial point patterns.

Using Singapore's childcare centres, we are curious about:

-   whether childcare centres in Singapore are randomly distributed throughout the country?

-   if not, the succeeding question is where are the locations with **higher concentration** of childcare centres?

## Preparation

### Packages

Let's use *pacman()* to first load the packages we will need to use. We require:

-   *sf* to import and process vector geospatial data

-   *tmap* to plot high quality (interactive) maps

-   *maptools* for manipulating geographic data

-   *spatstat* for point pattern analysis

-   *raster* to read, write, manipulate, analyse and model gridded spatial data (raster)


```{r}
pacman::p_load(sf, tmap, spatstat, raster)
```

```{r}
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```


### Data

| Name                                    | Source                                                                                                    |
|------------------------------------------------|------------------------|
| Pre-Schools Location (geojson)          | [data.gov.sg](https://beta.data.gov.sg/collections/2064/datasets/d_61eefab99958fd70e6aab17320a71f1c/view) |
| Master Plan 2014 Subzone Boundary (Web) | [data.gov.sg](https://beta.data.gov.sg/collections/1708/view)                                             |
| Coastal Outline                         | SLA                                                                                                       |

## Spatial Data Wrangling

### Importing Spatial Data

Geospatial data will be imported using \*st_read()\* from the sf package.


```{r}
childcare_sf <- st_read(dsn = "data/geospatial/PreSchoolsLocation.geojson") %>% st_transform(crs=3414)
```

```{r}
mpsz_sf <- st_read(dsn="data/geospatial", layer="MP14_SUBZONE_WEB_PL")
```

```{r}
sg_sf <- st_read(dsn = "data/geospatial", layer = "CostalOutline")
```


## Inspecting and Reprojecting CRS

*Childcare Data*


```{r}
st_crs(childcare_sf)
```


Now convert to the SVY21 Projected Coordinate System.


```{r}
childcare_sf <- st_transform(childcare_sf , crs = 3414)
```


*Coastal Outline Data*


```{r}
st_crs(sg_sf)
```


Since the ID provided is `EPSG:9001` which does not match the SVY21 Projected CRS, let's correct the CRS ID.


```{r}
sg_sf <- st_set_crs(sg_sf,3414)
```

```{r}
st_crs(sg_sf)
```


-   Note that there is the correct CRS now, `EPSG3414`.

*Master Plan Subzone* Inspect the CRS of mpsz_sf.


```{r}
st_crs(mpsz_sf)
```

```{r}
mpsz_sf <- st_set_crs(mpsz_sf,3414)
```

```{r}
st_crs(mpsz_sf)
```

-   ID has been set correctly


## Mapping Geospatial Data
After checking the CRS of each geospatial data frame, we can plot a map to see their spatial patterns.

### Static Map

```{r}
childcare_sf
```

```{r}
tm_shape(sg_sf)+
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(childcare_sf) +
  tm_dots()
```

For an interactive map,

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+tm_dots()
```


Remember to switch the mode to `plot`.


```{r}
tmap_mode('plot')
```


## Geospatial Data Wrangling

### Coverting sf Dataframes to sp Spatial\* Class


```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```


View information of Spatial\* classes:


```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```


### Coverting the Spatial\* Class into Generic sp Format

spstat requires the analytical data to be in ppp object form. As there is no direct method to convert Spatial\* classes to ppp object, we need to convert the Spatial\* classes into an intermediate Spatial object first.

Convert Spatial\* Classes into generic sp objects.


```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```


Check the sp object properties,


```{r}
childcare_sp
```

```{r}
sg_sp
```


The variables, names, min and max values are omitted from the sp object but present in Spatial\* Classes.

## Converting Generic sp Format into spatstat's ppp Format

Let's use [*as.ppp()*](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/as.ppp.html) of *spatstat* to convert the spatial data into object format.

Plot *childcare_ppp* and examine the difference.

```{r}
childcare_ppp <- as.ppp(st_coordinates(childcare_sf), st_bbox(childcare_sf)) 
plot(childcare_ppp)
```

Summary statistics:

```{r}
summary(childcare_ppp)
```

```{r}
any(duplicated(childcare_ppp))
```

```{r}
multiplicity(childcare_ppp)
```

```{r}
sum(multiplicity(childcare_ppp)>1)
```

View duplicated point events by plotting.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha = 0.4,
          size = 0.05)
```

```{r}
tmap_mode('plot')
```

There are a few ways to overcome this problem:

-   Delete the duplicates. However, some useful point events will be lost 

-   jittering. Adds small perturrbations to duplicate points so that they do not occupy the same exact space

-   Make each point “unique” and then attach duplicates of points to the patterns as marks, as attributes of the points. Then we can use analytical techniques that take into account the marks.

Using jittering,

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

## Creating *owin* object
When analysing spatial point patterns, it is good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

The code cunk below is used to convert the sg SpatialPolygon object into owin object of spatstat.

```{r}
sg_owin <- as.owin(sg_sf)
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

### Combining point events object and owin object
This step of geospatial data wrangling, we will extract childcare events that are located within Singapore.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```


The output object combined both the point and polygon feature in one ppp object class.

```{r}
summary(childcareSG_ppp)
```

```{r}
plot(childcareSG_ppp)
```


# First-order Spatial Point Patterns Analysis
First-order SPPA can be performed using **spastat** package. This section focuses on:
-   deriving **kernel density estimation (KDE)** layer for visualising and exploring the inntensity of point processes,
-   performing **Confirmatory Spatial Point Patterns Analysis** by using **Nearest Neighbour** statistics.

## Kernel Density Estimation
### Computing Kernel Density Estimation using Automatic Bandwidth Selection Method
The code below computes a kernel density by using the following configurations of *density()* of spatstat:
-   *bw.diggle()* automatic bandwidth selection method. Other recommended methods include: *bw.CvL*, *bw.scott()*, *bw.ppl()*. 
-   The smoothing kernel used by default is *gaussian*. Other smoothing methods include: *epanechnikov, quartic or disc*
-   The intensity estimate is corrected for edge effect bias by using the method described by Jones (1993) and Diggle (2010). The default is FALSE.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

plot(kde_childcareSG_bw)
```


The density values of the output range is too small for us to derive any practical insights. The output range is due to the default unit of measurement of svy21 being in meter. As such, the density values computed is in "number of points per square meter".

We can check the bandwidth used to compute the kde layer by using the following code:

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### Rescaling KDE values
The function *rescale()* is used to convert the unit of measurement from metres to kilometres.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```


Now re-run *density()* using the resale data set and plot the output kde map.

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

-   Now the data values are better and more readible and comprehensible.

## Working with different automatic bandwidth methods
Besides *bw.diggle()*, there are three other **spatstat** functions can be used to determine the bandwidth, they are: *bw.CvL()*, *bw.scott()*, and *bw.ppl()*.

```{r}
bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```


Baddeley et al. (2016) suggested the use of *bw.ppl()* algorithm because in their experience, the algorithm tends to produce the more appropriate values when the pattern consists predominantly tight clusters. However, they also insist that if the purpose is to detect a single tight cluster in the midst of random noise then *bw.diggle()* is the best.

Comparing the output of using *bw.diggle* and *bw.ppl* methods,

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```


## Working with different kernel methods
The default kernel method used in *density.ppp()* is *gaussian*. There are other options, namely *epanechnikov, quartic and dics*.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel functions.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```


## Fixed and Adaptive KDE
### Computing KDE by using fixed bandwidth
Compute a KDE layer by defining a bandwidth of 600m. The sigma value depends on the unit of measurement in the kde variable. In our case, ***childcareSG_ppp.km*** object is in kilometres, hence, 600m will be 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```


## Computing KDE by using adaptive bandwidth
Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

This section derive s the adaptive kernel density estimation by using density.adaptive() of **spatstat**.


```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```


Compare the fixed and adaptive kernel density estimation outputs by using the following code chunk,

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```


## Computing KDE by using adaptive bandwidth
Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geological units, i.e. urban vs rural. One way to overcoem this problem is by using adaptive bandwidth instead.

This section focuses on how to derive adaptive kernel density estimation by using *density.adaptive()* of **spatstat**.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```


Compare the fixed and adaptive kernel density estimation outputs,

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```


## Converting KDE output into grid object
Convert the result into grid object such that it is suitable for mapping purposes.

### Converting Fridded Output into Raster


