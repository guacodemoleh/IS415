---
title: "Hands-on Exercise 3: Spatial Point Patterns Analysis"
author: "Victoria Grace ANN"
execute: 
  warning: false
  eval: true
  echo: true
format:  
  html: 
    code-summary: "Show the code"
    toc-depth: 4
date: "16 January, 2024"
date-modified: "last-modified"
editor: visual
---

# Lecture on Spatial Point Pattern Analysis

Spatial point patterns can be seen through many events and they are not limited to human activities. When there is data captured from a location, it can be considered as a spatial point. Such spatial points help analysts to observe any statistical patterns that are significant. In this context, we will only consider the points to be on isotropic (flat) planes.

Spatial point patterns exist in a Euclidean space which is in a 2-dimensional space. When the arrangement of the points is non-random, there should be underlying factors causing it.

## Spatial Point Pattern Analysis Techniques

### First-order

-   Expected values of spatial point patterns vary across space, like the intensity of spatial point pattern

*Kernel Density*

-   Depending on how points you want to capture, the *bandwidth* can be adjusted, i.e Adaptive bandwidth

-   When data is sparse, we can consider Fixed bandwidth

*Quadrat Analysis*

-   Used more frequently in Ecology

-   Count the frequency of events in each region thencalculate the intensity of events in each region

-   Variance-Mean Ratio (VMR)

    -   Uniform distribution, VMR \~ 0

    -   Random distribution, VMR \~ 1

    -   Cluster distribution, VMR \> 1

### Second-order

-   Covariance and correlation between spatial points of different regions

-   Measured using G, K and L function.

*Nearest Neighbour Index (NNI)*

-   Random distribution when Mean Distance \~ 1

-   Clustered distribution when Mean Distance \~ 0

-   Uniformed distribution when Mean Distance \> 1

# 1st Order Spatial Point Patterns Analysis

[*spatstat*](https://cran.r-project.org/web/packages/spatstat/) is an open-source toolbox for analysing spatial point patterns.

Using Singapore's childcare centres, we are curious about:

-   whether childcare centres in Singapore are randomly distributed throughout the country?

-   if not, the succeeding question is where are the locations with **higher concentration** of childcare centres?

## Preparation

### Packages

Let's use *pacman()* to first load the packages we will need to use. We require:

-   *sf* to import and process vector geospatial data

-   *tmap* to plot high quality (interactive) maps

-   *maptools* for manipulating geographic data

-   *spatstat* for point pattern analysis

-   *raster* to read, write, manipulate, analyse and model gridded spatial data (raster)

-   *tidyverse* for data transformation

maptools has been deprecated so,

```{r}
#| eval: false
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

```{r}
pacman::p_load(sf, tmap, spatstat, raster,sp, maptools, tidyverse)
```

### Data

| Name                                    | Source                                                        |
|-----------------------------------------|---------------------------------------------------------------|
| Child Care Location (geojson)           | [data.gov.sg](https://beta.data.gov.sg/collections/2015/view) |
| Master Plan 2014 Subzone Boundary (Web) | [data.gov.sg](https://beta.data.gov.sg/collections/1708/view) |
| Coastal Outline                         | SLA                                                           |

## Spatial Data Wrangling

### Importing Spatial Data

Geospatial data will be imported using \*st_read()\* from the sf package.

```{r}
childcare_sf <- st_read(dsn = "data/geospatial/ChildCareServices.geojson") %>% st_transform(crs=3414)
```

```{r}
mpsz_sf <- st_read(dsn="data/geospatial", layer="MP14_SUBZONE_WEB_PL")
print(class(mpsz_sf))
```

```{r}
sg_sf <- st_read(dsn = "data/geospatial", layer = "CostalOutline")
```

Learning from Lesson 1, we can also extract the coastal outline from the `MP14 SUBZONE_WEB_PL` layer.

```{r}
sg_sf <- mpsz_sf %>% st_union()
plot(sg_sf)
```

## Inspecting and Reprojecting CRS

*Childcare Data*

```{r}
st_crs(childcare_sf)
```

Now convert to the SVY21 Projected Coordinate System.

```{r}
childcare_sf <- st_transform(childcare_sf , crs = 3414)
```

*Coastal Outline Data*

```{r}
st_crs(sg_sf)
```

Since the ID provided is `EPSG:9001` which does not match the SVY21 Projected CRS, let's correct the CRS ID.

```{r}
sg_sf <- st_set_crs(sg_sf,3414)
```

```{r}
st_crs(sg_sf)
```

-   Note that there is the correct CRS now, `EPSG3414`.

*Master Plan Subzone* Inspect the CRS of mpsz_sf.

```{r}
st_crs(mpsz_sf)
```

```{r}
mpsz_sf <- st_set_crs(mpsz_sf,3414)
```

```{r}
st_crs(mpsz_sf)
```

-   ID has been set correctly

## Mapping Geospatial Data

After checking the CRS of each geospatial data frame, we can plot a map to see their spatial patterns.

### Static Map

```{r}
childcare_sf
```

```{r}
tm_shape(sg_sf)+
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(childcare_sf) +
  tm_dots()
```

For an interactive map,

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+tm_dots()
```

Remember to switch the mode to `plot`.

```{r}
tmap_mode('plot')
```

## Geospatial Data Wrangling

### Coverting sf Dataframes to sp Spatial\* Class

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

View information of Spatial\* classes:

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

### Coverting the Spatial\* Class into Generic sp Format

spstat requires the analytical data to be in ppp object form. As there is no direct method to convert Spatial\* classes to ppp object, we need to convert the Spatial\* classes into an intermediate Spatial object first.

Convert Spatial\* Classes into generic sp objects.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

Check the sp object properties,

```{r}
childcare_sp
```

```{r}
sg_sp
```

The variables, names, min and max values are omitted from the sp object but present in Spatial\* Classes.

## Converting Generic sf Format into spatstat's ppp Format

Let's use [*as.ppp()*](https://search.r-project.org/CRAN/refmans/spatstat.geom/html/as.ppp.html) of *spatstat* to convert the sf into ppp format.

Plot *childcare_ppp* and examine the difference.

```{r}
childcare_ppp <- as.ppp(st_coordinates(childcare_sf), st_bbox(childcare_sf)) 
plot(childcare_ppp)
```

Summary statistics:

```{r}
summary(childcare_ppp)
```

```{r}
any(duplicated(childcare_ppp))
```

```{r}
multiplicity(childcare_ppp)
```

```{r}
sum(multiplicity(childcare_ppp)>1)
```

View duplicated point events by plotting.

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha = 0.4,
          size = 0.05)
```

```{r}
tmap_mode('plot')
```

There are a few ways to overcome this problem:

-   Delete the duplicates. However, some useful point events will be lost

-   jittering. Adds small perturbations to duplicate points so that they do not occupy the same exact space

-   Make each point “unique” and then attach duplicates of points to the patterns as marks, as attributes of the points. Then we can use analytical techniques that take into account the marks.

Using jittering,

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp,
                             retry = TRUE,
                             nsim = 1,
                             drop = TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

## Creating *owin* object

When analysing spatial point patterns, it is good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

The code chunk below is used to convert the sg simplefeatures object into owin object of spatstat.

```{r}
sg_owin <- as.owin(sg_sf)
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

### Combining point events object and owin object

This step of geospatial data wrangling, we will extract childcare events that are located within Singapore.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

The output object combined both the point and polygon feature in one ppp object class.

```{r}
summary(childcareSG_ppp)
```

```{r}
plot(childcareSG_ppp)
```

# First-order Spatial Point Patterns Analysis

First-order SPPA can be performed using **spastat** package. This section focuses on:

-   deriving **kernel density estimation (KDE)** layer for visualising and exploring the inntensity of point processes,

-   performing **Confirmatory Spatial Point Patterns Analysis** by using **Nearest Neighbour** statistics.

## Kernel Density Estimation

### Computing Kernel Density Estimation using Automatic Bandwidth Selection Method

The code below computes a kernel density by using the following configurations of *density()* of spatstat:

-   *bw.diggle()* automatic bandwidth selection method. Other recommended methods include: *bw.CvL*, *bw.scott()*, *bw.ppl()*.

-   The smoothing kernel used by default is *gaussian*. Other smoothing methods include: *epanechnikov, quartic or disc*

-   The intensity estimate is corrected for edge effect bias by using the method described by Jones (1993) and Diggle (2010). The default is FALSE.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

plot(kde_childcareSG_bw)
```

The density values of the output range is too small for us to derive any practical insights. The output range is due to the default unit of measurement of svy21 being in meter. As such, the density values computed is in "number of points per square meter".

We can check the bandwidth used to compute the kde layer by using the following code:

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### Rescaling KDE values

The function *rescale()* is used to convert the unit of measurement from metres to kilometres.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

Now re-run *density()* using the resale data set and plot the output kde map.

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

-   Now the data values are better and more readible and comprehensible.

## Working with different automatic bandwidth methods

Besides *bw.diggle()*, there are three other **spatstat** functions can be used to determine the bandwidth, they are: *bw.CvL()*, *bw.scott()*, and *bw.ppl()*.

```{r}
bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

Baddeley et al. (2016) suggested the use of *bw.ppl()* algorithm because in their experience, the algorithm tends to produce the more appropriate values when the pattern consists predominantly tight clusters. However, they also insist that if the purpose is to detect a single tight cluster in the midst of random noise then *bw.diggle()* is the best.

Comparing the output of using *bw.diggle* and *bw.ppl* methods,

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

## Working with different kernel methods

The default kernel method used in *density.ppp()* is *gaussian*. There are other options, namely *epanechnikov, quartic and dics*.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel functions.

```{r}
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))  # adjust the margin values to resolve margin issue

plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "gaussian"), main = "Gaussian")
plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "epanechnikov"), main = "Epanechnikov")
plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "quartic"), main = "Quartic")
plot(density(childcareSG_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "disc"), main = "Disc")
```

## Fixed and Adaptive KDE

### Computing KDE by using fixed bandwidth

Compute a KDE layer by defining a bandwidth of 600m. The sigma value depends on the unit of measurement in the kde variable. In our case, ***childcareSG_ppp.km*** object is in kilometres, hence, 600m will be 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

### Computing KDE by using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

This section derive s the adaptive kernel density estimation by using density.adaptive() of **spatstat**.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

Compare the fixed and adaptive kernel density estimation outputs by using the following code chunk,

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### Computing KDE by using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geological units, i.e. urban vs rural. One way to overcome this problem is by using adaptive bandwidth instead.

This section focuses on how to derive adaptive kernel density estimation by using *density.adaptive()* of **spatstat**.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive) 
```

Compare the fixed and adaptive kernel density estimation outputs,

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### Converting KDE output into grid object

Convert the result into grid object such that it is suitable for mapping purposes.

```{r}
# to solve "could not find function "as.SpatialGridDataFrame.im""
#install.packages("spatial")
#install.packages("sp")
```

```{r}
# to solve "could not find function "as.SpatialGridDataFrame.im"" 
library(spatial)
library(sp)
```

```{r}
# Debugging: check if object class is im
if ("im" %in% class(kde_childcareSG.bw)) {
  print("The object is of class 'im'")
} else {
  print("The object is not of class 'im'")
}
```

```{r}
gridded_kde_childcareSG_bw <- as(kde_childcareSG.bw, "SpatialGridDataFrame")

spplot(gridded_kde_childcareSG_bw)
```

#### Converting Gridded Output into Raster

Next, do the conversion by using *raster()* from the **raster** package.

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Then observe the properties of the raster layer,

```{r}
kde_childcareSG_bw_raster
```

-   A raster layer does not have any CRS property, thus its value is NA after the grid (vector) is rasterised.

#### Assigning projection systems

The code below will be used to include CRS information

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

### Visualising tmap output

Finally, we can display the raster in cartographic quality map using **tmap** package.

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

-   Note that the raster values are encoded explicitly onto the raster pixel using the values in the “v” field.

### Comparing Spatial Point Patterns using KDE

Here, we will compare the KDE of childcare centres at various planning areas.

#### Extracting Study Areas Let's categorise and extract the planning areas of interest.

```{r}
pg <- mpsz_sf %>% 
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>% 
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>% 
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>% 
  filter(PLN_AREA_N == "JURONG WEST")
```

Then plot the planning areas.

```{r}
par(mfrow=c(2,2))
par(mar = c(3,3,2,1))
plot(pg, main = "Punggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

#### Creating ***owin*** object

Now, we will convert the SpatialPolygons objects into owin objects required by **spatstat**.

```{r}
pg_owin <- as.owin(pg)
tm_owin <- as.owin(tm)
ck_owin <- as.owin(ck)
jw_owin <- as.owin(jw)
```

#### Combining childcare points and the study area

Extract the childcare centre points within each of the study planning areas.

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Then use *rescale()* to transform the unit of measurement from metre to kilometre.

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

Then plot the four study areas together with their childcare centres.

```{r}
par(mfrow=c(2,2))
par(mar = c(3,3,2,1))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### Computing KDE

The code chunk below is used to compute the KDE of the four planning areas. ***bw.diggle*** is used to derive the bandwidth of each planning area.

```{r}
par(mfrow=c(2,2))
par(mar = c(3,3,2,1))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Jurong West")
```

#### Computing fixed bandwidth KDE

For comparison purposes, let's use 250m as the bandwidth

```{r}
par(mfrow=c(2,2))
par(mar = c(3,3,2,1))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

# Nearest Neighbour Analysis

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using clarkevans.test() of statspat at 95% confidence interval.

The test hypotheses are: - H0: The distribution of childcare services are randomly distributed. - H1: The distribution of childcare services are not randomly distributed.

## Testing Spatial Point Patterns using Clark and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

As P \< 0.05, we reject the null hypothesis that the childcare services are randomly distributed.

## Clark and Evans Test: Choa Chu Kang planning area

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

As P \> 0.05, we cannot reject the null hypothesis that the childcare services are randomly distributed in Choa Chu Kang.

## Clark and Evans Test: Tampines planning area

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

As P \< 0.05, we reject the null hypothesis that the childcare services are randomly distributed.

We can infer from the R value (Nearest Neighbour Index) that since R = 0.69037 \< 1, the pattern exhibits clustering in Tampines.

# Second-order Spatial Point Patterns Analysis

# Analysing Spatial Point Process Using G-Function

The G function measures the distribution of the distances from an arbitrary event to its nearest event. This section focuses on how to compute G-function estimation using *Gest()* of **spatstat** package. Additionally, Monte Carlo simulation test will be performed using *envelope()* of **spatstat package**

## Choa Chu Kang planning area

### Computing G-function estimation

The code chunk below is used to comput G-function using Gest() of **spastat** package

```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

### Performing Complete Spatial Randomness Test

H0: The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1: The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-fucntion

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

```{r}
plot(G_CK.csr)
```

## Tampines planning area

### Computing G-function estimation

```{r}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```
