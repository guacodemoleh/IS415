{
  "hash": "0dde63dd148edecd1a39da5c49552677",
  "result": {
    "markdown": "---\ntitle: \"In-class Exercise 7\"\nauthor: \"Victoria Grace ANN\"\nexecute: \n  warning: false\n  eval: true\n  echo: true\n  freeze: true\nformat:  \n  html: \n    code-summary: \"Show the code\"\n    toc-depth: 4\ndate: \"4 March, 2024\"\ndate-modified: \"last-modified\"\neditor: visual\n---\n\n\n# Loading R packagess\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sp,spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\n-   GDAL is no longer in use, thus replaced with **sp**\n\n\n# Importing data\n\nUsing *filter* **dplyr** function to select Shan state data,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\guacodemoleh\\IS415-GAA\\In-class_Ex\\In-class_Ex07\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n-   The data is filtering for all the Shan state regions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv(\"data/aspatial/Shan-ICT.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 55 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n\n-   The *rename* function enables the column names to be shorter and refined\n\n\n# Visulisations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nradio <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv <- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone <- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet <- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nggarrange(radio, tv, llphone, mphone, computer, internet, \n          ncol = 3, \n          nrow = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n-   *ggarrange* to define the order of the histograms.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \nwrite_rds(shan_sf, \"data/rds/shan_sf.rds\")\n```\n:::\n\n\n-   the first argument of the *left_join()* should be a sf object\n\n-   note that *st_join()* requires both data to be spatial\n\n\n# Correlation Analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n          tl.col = \"black\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n# Extracting clustering variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\n-   *st_set_geometry(NULL)* needs to be used so that the resulting cluster data can remain as a traditional dataset with no geometry attribute.\n\n\nChange the rows by township name rather than row number for easier referencing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_distinct(cluster_vars$TS.x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit     Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya     Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan     Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\nMabein       Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw         Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\nPekon         Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme     Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\nThe first column can be excluded from our focus since the township name is captured in the row name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit   286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya   417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan   484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung  231.6499 541.7189   28.54454  249.4903    13.76255\nMabein    449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw     280.7624 611.6204   42.06478  408.7951    29.63160\nPekon     318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk  387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme   210.9548 601.1773   39.58267  372.4930    30.94709\n```\n:::\n:::\n\n\n\n# Min-Max standardisation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n```\n:::\n:::\n\n\n\n# Computing Proximity Matrix\n\nThe *dist()* function supports six distance proximity calculations: - euclidean (default) - maximum - minimum - canberra - binary - minkowski\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = 'euclidean')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat\n```\n:::\n\n\n\n# Computing Hierarchical Clustering\n\n*hclust()* employs an agglomeration method to compute the cluster. The eight clustering algorithms supported ward.D, ward.D2, single, complete, average (UPGMA), mcquitty (WPGMA), median (WPGMC) and centroid (UPGMC).\n\nTo try hierarchical cluster analysis using the ward.D method,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n```\n:::\n\n\n-   the data must be a dissimilairty structure produced by `dist`\n\n\nPlot the tree using *plot()*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n# How to read dendogram\n-   Use a height value as the cut-off\n-   From there, you should be able to identify the number of clusters at that cut-off value\n:::\n\n\n# Determining Optimal Clusters\n\nThe common methods to determine the optimal clusters are: - Gap Statistic Method - Elbow Method - Average Silhouette Method\n\n##\nGap Statistic Method\n\nThe gap statistic compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic (i.e., that yields the largest gap statistic). This means that the clustering structure is far away from the random uniform distribution of points.\n\nTo compute the gap statistic, clusGap() of cluster package will be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(12345)\ngap_stat <- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = shan_ict, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 1\n          logW   E.logW       gap     SE.sim\n [1,] 8.407129 8.680794 0.2736651 0.04460994\n [2,] 8.130029 8.350712 0.2206824 0.03880130\n [3,] 7.992265 8.202550 0.2102844 0.03362652\n [4,] 7.862224 8.080655 0.2184311 0.03784781\n [5,] 7.756461 7.978022 0.2215615 0.03897071\n [6,] 7.665594 7.887777 0.2221833 0.03973087\n [7,] 7.590919 7.806333 0.2154145 0.04054939\n [8,] 7.526680 7.731619 0.2049390 0.04198644\n [9,] 7.458024 7.660795 0.2027705 0.04421874\n[10,] 7.377412 7.593858 0.2164465 0.04540947\n```\n:::\n:::\n\n\n\n\n::: callout-note\n*hcut* is from the **factoextra** package.\n:::\n\nVisualise the plot using *fviz_gap_stat()* of the **factoextra** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfviz_gap_stat(gap_stat)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n-   The optimisation is local.\n-   6 is the optimal number of clusters since it is the first peak.\n\n\n# Interpreting Dendrograms\n\nEach leaf in a dendrogram corresponds to one observation. Observations similar to each other are combined into branches as shown by tracing the dendrogram from bottom to top.\n\nThe **height** of these fused branches indicates the (dis)similarity between two observations. The higher these fusions, the less similar the observations.\n\nTo draw the dendogram with a border around the selected clusters using *rect.hclust()*, the argument `border` is used to specify the border colours of the rectangles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n# Mapping Formed Clusters\n\nUse *cutree()* to derive a 6-cluster model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(hclust_ward, k=6))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n```\n:::\n\n-   *cbind* can be used to append `groups` to `shan_sf`. This is because the order of the rows did not change. However, if there is sorting done, then doing this method is not appropriate.\n\n\nHave a look at where are the clusters using a choropleth map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqtm(shan_sf_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n# Computing Neighbour List\n\nFrom a previous exercise, apply *poly2nb()* to compute the neighbours list for all the polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sf)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n:::\n:::\n\n\n-   Now *poly2nb()* can read sf files!\n\n\nSince our data is in sf, we need to get the centroid for each township so that we get our point object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=grey(.5))\n\npts <- st_coordinates(st_centroid(shan_sf))\nplot(shan.nb, \n     pts, \n     col=\"blue\", \n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n-   *st_geometry()* helps to generate just one map polygon!\n\n\n# Computing MST\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n     border=gray(.5))\n\nlcosts <- nbcosts(shan.nb, shan_ict)\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nshan.mst <- mstree(shan.w)\n\nplot.mst(shan.mst, \n         pts, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n# Ward-like hierarchical clustering: ClustGeo\n\nTypically, *hclustgeo()* performs Ward-like hierarchical clustering like what *hclust()* does.\n\nTo perform non-spatially constrained hierarchical clustering, we only need to pass a dissimilarity matrix in the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n# Mapping the formed clusters\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n# Multivariate Visualisation\n\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, ggparcoord() of GGally package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n::: {.cell-output-display}\n![](In-class_Ex07_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nCluster 5 has the lowest ownership of ICTs.\n",
    "supporting": [
      "In-class_Ex07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}